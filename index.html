<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#070a14" />
  <title>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ…</title>
  <link rel="manifest" href="manifest.json" />
  <style>
    html, body { margin:0; height:100%; background:#070a14; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; }
    #wrap { position: relative; width:100%; height:100%; }
    canvas { width:100%; height:100%; display:block; touch-action:none; }

    .hud{
      position:absolute; left:12px; top:12px;
      color:#fff; font-weight:900; font-size:13.5px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.75);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      max-width: calc(100% - 170px);
      pointer-events:none;
    }
    .hud span{
      opacity:0.95; padding:6px 10px; border-radius:14px;
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.08);
    }
    .btns{ position:absolute; right:12px; top:12px; display:flex; gap:8px; }
    button{
      appearance:none; border:0; border-radius:14px; padding:10px 12px;
      font-weight:900; background:rgba(255,255,255,0.12); color:#fff; backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.08);
    }
    button:active{ transform: translateY(1px); }

    .panel{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      color:#fff; text-align:center;
      padding:14px 16px; border-radius:18px;
      background:rgba(0,0,0,0.48);
      width:min(520px, 92vw);
      line-height:1.4;
      box-shadow: 0 14px 40px rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .panel b{ font-size:18px; display:block; margin-bottom:10px; }
    .panel small{ opacity:0.92; display:block; margin-top:10px; }

    .toast{
      position:absolute; left:50%; bottom:18px;
      transform:translateX(-50%);
      color:#fff; font-weight:900;
      background: rgba(0,0,0,0.55);
      padding:10px 12px; border-radius:14px;
      opacity:0; pointer-events:none;
      transition: opacity 160ms ease;
      border:1px solid rgba(255,255,255,0.08);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    }
    .toast.show{ opacity:1; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <span id="stage">ìŠ¤í…Œì´ì§€: 1/10</span>
    <span id="score">ì ìˆ˜: 0</span>
    <span id="best">ìµœê³ : 0</span>
    <span id="life">ëª©ìˆ¨: 10</span>
    <span id="pow">íŒŒì›Œì—…: W0 R0 L0</span>
  </div>

  <div class="btns">
    <button id="soundBtn">ì‚¬ìš´ë“œ ON</button>
    <button id="pauseBtn">ì¼ì‹œì •ì§€</button>
    <button id="restartBtn">ì¬ì‹œì‘</button>
  </div>

  <div id="panel" class="panel">
    <b>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ… âœˆï¸</b>
    <div>í™”ë©´ì„ <b>í„°ì¹˜í•´ì„œ ë“œë˜ê·¸</b>í•˜ë©´ ë¹„í–‰ê¸°ê°€ ì›€ì§ì—¬ìš”.</div>
    <div>ğŸ”« ìë™ë°œì‚¬ / ğŸ˜ˆ ì  íƒ„ë§‰ / ğŸ íŒŒì›Œì—… 3ì¢… / ğŸ‘‘ ìŠ¤í…Œì´ì§€ ë³´ìŠ¤</div>
    <div style="margin-top:10px; font-weight:900;">íŒŒì›Œì—… 3ì¢…</div>
    <div>ğŸŸ¦ WIDE(ì™€ì´ë“œ): íƒ„ì´ ì˜†ìœ¼ë¡œ ëŠ˜ì–´ë‚¨</div>
    <div>ğŸŸ© RAPID(ì—°ì‚¬): ë°œì‚¬ ì†ë„ ì¦ê°€</div>
    <div>ğŸŸª LASER(ë ˆì´ì €): ê´€í†µ/ê³ ë°ë¯¸ì§€ íƒ„</div>
    <small>(ì•„ë¬´ ê³³ì´ë‚˜ í„°ì¹˜í•˜ë©´ ì‹œì‘)</small>
  </div>

  <div id="toast" class="toast">POWER UP!</div>
</div>

<script>
(() => {
  // ============================
  // âœ… ì•„ì´ ëª¨ë“œ(ì†ë„ ì¡°ì ˆ)
  // ============================
  // 0.70~0.85 ê¶Œì¥ (ìˆ«ì ë‚®ì„ìˆ˜ë¡ ë” ëŠë¦¼)
  const KID_SPEED = 0.75;

  // stage ë‚œì´ë„ ìƒìŠ¹ë¥  (ê¸°ì¡´ 10%ëŠ” ì•„ì´ì—ê²Œ ë¹ ë¦„)
  const STAGE_GROWTH = 1.07; // ìŠ¤í…Œì´ì§€ ì˜¬ë¼ê°ˆ ë•Œë§ˆë‹¤ ì•½ 7% ìƒìŠ¹

  // PWA
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
  }

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // roundRect ì•ˆì „ ì²˜ë¦¬(ì¼ë¶€ í™˜ê²½ ëŒ€ë¹„)
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  const elStage = document.getElementById('stage');
  const elScore = document.getElementById('score');
  const elBest  = document.getElementById('best');
  const elLife  = document.getElementById('life');
  const elPow   = document.getElementById('pow');

  const panel = document.getElementById('panel');
  const toast = document.getElementById('toast');

  const soundBtn = document.getElementById('soundBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  let W=0, H=0, DPR=1;

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- Sound (WebAudio) ----------
  let audioEnabled = true;
  soundBtn.textContent = 'ì‚¬ìš´ë“œ ON';

  function beep(freq=440, dur=0.06, type='sine', gain=0.06) {
    if (!audioEnabled) return;
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) return;
    const ac = beep._ac || (beep._ac = new AudioCtx());
    if (ac.state === 'suspended') ac.resume().catch(()=>{});
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = gain;
    o.connect(g); g.connect(ac.destination);
    const t = ac.currentTime;
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.start(t); o.stop(t + dur);
  }
  const sfx = {
    start(){ beep(660,0.06,'triangle',0.06); beep(880,0.06,'triangle',0.05); },
    shoot(){ beep(780,0.03,'square',0.040); },
    laser(){ beep(980,0.04,'sawtooth',0.040); },
    hit(){ beep(140,0.10,'sawtooth',0.075); },
    boom(){ beep(220,0.06,'square',0.06); beep(110,0.10,'sawtooth',0.05); },
    power(){ beep(980,0.06,'triangle',0.08); beep(1320,0.06,'triangle',0.06); },
    enemyShoot(){ beep(420,0.04,'sine',0.028); },
    boss(){ beep(240,0.12,'square',0.07); beep(180,0.14,'square',0.05); },
    clear(){ beep(880,0.08,'triangle',0.07); beep(1320,0.10,'triangle',0.06); beep(1760,0.12,'triangle',0.05); }
  };

  soundBtn.addEventListener('click', () => {
    audioEnabled = !audioEnabled;
    soundBtn.textContent = audioEnabled ? 'ì‚¬ìš´ë“œ ON' : 'ì‚¬ìš´ë“œ OFF';
    beep(440,0.04,'sine',0.04);
  });

  function showToast(text){
    toast.textContent = text;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 560);
  }

  // ---------- Game State ----------
  const MAX_STAGE = 10;

  const state = {
    running:false, paused:false, gameOver:false, cleared:false,
    t:0, lastTs:0,

    stage:1,
    score:0,
    best:Number(localStorage.getItem('minwoo_stage_best_v3') || 0),

    lives:10,
    invuln:0,

    // powerups
    wideLv:0,   // 0~4
    rapidLv:0,  // 0~4
    laserLv:0,  // 0~3

    bgScroll:0,

    kills:0,
    killsToBoss: 26,
    bossActive:false,

    diffMul: 1.0,

    enemySpawnTimer:0,
    enemySpawnEvery:0.70,  // âœ… ë” ëŠë¦¬ê²Œ
    enemySpeed: 190,       // âœ… ë” ëŠë¦¬ê²Œ
    enemyFireEvery:1.20,   // âœ… ë” ëŠë¦¬ê²Œ

    boss:null,
  };

  function updateHud(){
    elStage.textContent = `ìŠ¤í…Œì´ì§€: ${state.stage}/${MAX_STAGE}`;
    elScore.textContent = `ì ìˆ˜: ${Math.floor(state.score)}`;
    elBest.textContent  = `ìµœê³ : ${state.best}`;
    elLife.textContent  = `ëª©ìˆ¨: ${state.lives}`;
    elPow.textContent   = `íŒŒì›Œì—…: W${state.wideLv} R${state.rapidLv} L${state.laserLv}`;
  }
  updateHud();

  // ---------- Objects ----------
  const player = { x: W*0.5, y: H*0.82, r:18, targetX:null, targetY:null };

  const enemies = [];        // {x,y,w,h,vy,hp,shootCd,kind,wiggle,t0}
  const pBullets = [];       // {x,y,vx,vy,r,damage,type,pierce}
  const eBullets = [];       // {x,y,vx,vy,r,damage,kind}
  const powerups = [];       // {x,y,vy,r,type}
  const sparks = [];         // {x,y,vx,vy,life,col}
  const rings  = [];         // {x,y,r,vr,life,col}

  // ---------- Controls ----------
  let isPointerDown=false;
  function pointerPos(e){
    const rect = canvas.getBoundingClientRect();
    return { x: (e.clientX-rect.left), y:(e.clientY-rect.top) };
  }
  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    isPointerDown=true;
    const p = pointerPos(e);

    if(!state.running && !state.gameOver && !state.cleared){
      state.running=true; panel.style.display='none'; sfx.start();
    } else if(state.gameOver || state.cleared){
      resetGame();
      state.running=true; panel.style.display='none'; sfx.start();
    } else if(!state.running && !state.paused && !state.gameOver){
      state.running=true; panel.style.display='none'; sfx.start();
    }

    player.targetX=p.x; player.targetY=p.y;
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!isPointerDown) return;
    const p = pointerPos(e);
    player.targetX=p.x; player.targetY=p.y;
  });
  canvas.addEventListener('pointerup', ()=>{
    isPointerDown=false;
    player.targetX=null; player.targetY=null;
  });

  pauseBtn.addEventListener('click', ()=>{
    if(!state.running && !state.gameOver) return;
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? 'ì¬ê°œ' : 'ì¼ì‹œì •ì§€';
    beep(300,0.04,'sine',0.04);
  });

  restartBtn.addEventListener('click', ()=>{
    resetGame();
    state.running=true;
    panel.style.display='none';
    sfx.start();
  });

  // ---------- Helpers ----------
  function circleHit(ax,ay,ar,bx,by,br){
    const dx=ax-bx, dy=ay-by;
    const rr=ar+br;
    return (dx*dx+dy*dy) <= rr*rr;
  }

  function boom(x,y,amount=18, col='#ffcc66'){
    for(let i=0;i<amount;i++){
      const a = rand(0, Math.PI*2);
      const sp = rand(70, 340); // âœ… í­ë°œ íŒŒí¸ ì†ë„ë„ ì‚´ì§ ì™„í™”
      sparks.push({x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.18,0.55), col});
    }
    rings.push({x,y, r: 6, vr: rand(220, 420), life: rand(0.18, 0.32), col});
    sfx.boom();
    if(navigator.vibrate) navigator.vibrate(10);
  }

  function onPlayerHit(dmg=1){
    if(state.invuln>0) return;
    state.lives -= dmg;
    state.invuln = 1.10;
    sfx.hit();
    if(navigator.vibrate) navigator.vibrate(60);
    updateHud();

    if(state.lives<=0){
      gameOver();
    } else {
      showToast(`-1 ëª©ìˆ¨! (ë‚¨ì€ ${state.lives})`);
    }
  }

  function dropPowerup(x,y){
    const p = clamp(0.22 + (state.stage-1)*0.01, 0.22, 0.32);
    if(Math.random() < p){
      const r = Math.random();
      let type = 'WIDE';
      if(r < 0.34) type = 'WIDE';
      else if(r < 0.68) type = 'RAPID';
      else type = 'LASER';
      powerups.push({x,y, vy: 120 * state.diffMul, r: 12, type}); // âœ… ë–¨ì–´ì§€ëŠ” ì†ë„ë„ ì™„í™”
    }
  }

  function applyPowerup(type){
    if(type==='WIDE'){
      state.wideLv = Math.min(4, state.wideLv + 1);
      sfx.power(); showToast(`ğŸŸ¦ WIDE UP! (${state.wideLv})`);
    } else if(type==='RAPID'){
      state.rapidLv = Math.min(4, state.rapidLv + 1);
      sfx.power(); showToast(`ğŸŸ© RAPID UP! (${state.rapidLv})`);
    } else if(type==='LASER'){
      state.laserLv = Math.min(3, state.laserLv + 1);
      sfx.power(); showToast(`ğŸŸª LASER UP! (${state.laserLv})`);
    }
    if(navigator.vibrate) navigator.vibrate([14,14,14]);
    updateHud();
  }

  // ---------- Stage / Difficulty ----------
  function setStage(n){
    state.stage = n;
    state.kills = 0;
    state.bossActive = false;
    state.boss = null;

    // âœ… ìŠ¤í…Œì´ì§€ ìƒìŠ¹ í­ ì™„í™” (ì•„ì´ìš©)
    state.diffMul = Math.pow(STAGE_GROWTH, state.stage - 1);

    // âœ… ê¸°ë³¸ ê°’ ìì²´ë¥¼ ëŠë¦¬ê²Œ ì„¤ê³„
    state.enemySpeed = 190 * state.diffMul;
    state.enemySpawnEvery = clamp(0.72 / state.diffMul, 0.34, 0.72);
    state.enemyFireEvery  = clamp(1.25 / state.diffMul, 0.55, 1.25);

    // ë³´ìŠ¤ ì¶œí˜„ ì¡°ê±´
    state.killsToBoss = Math.floor(22 + state.stage * 5);

    enemies.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;

    updateHud();
  }

  function resetGame(){
    state.running=false; state.paused=false; state.gameOver=false; state.cleared=false;
    state.t=0; state.bgScroll=0;
    state.score=0;
    state.lives=10;
    state.invuln=0;
    state.wideLv=0; state.rapidLv=0; state.laserLv=0;

    enemies.length=0; pBullets.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;

    player.x=W*0.5; player.y=H*0.82;
    player.targetX=null; player.targetY=null;

    state.enemySpawnTimer=0;
    state._fireTimer=0;

    setStage(1);

    panel.style.display='block';
    panel.innerHTML = `
      <b>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ… âœˆï¸</b>
      <div>ë“œë˜ê·¸ ì´ë™ / ìë™ë°œì‚¬ / ì  íƒ„ë§‰</div>
      <div style="margin-top:8px; font-weight:900;">íŒŒì›Œì—… 3ì¢…: ğŸŸ¦WIDE ğŸŸ©RAPID ğŸŸªLASER</div>
      <div>ë³´ìŠ¤ëŠ” ë‚´ë ¤ì˜¤ë‹¤ ë©ˆì¶”ê³ , ì¡ìœ¼ë©´ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´!</div>
      <small>(ì•„ë¬´ ê³³ì´ë‚˜ í„°ì¹˜í•˜ë©´ ì‹œì‘)</small>
    `;
    pauseBtn.textContent='ì¼ì‹œì •ì§€';
    updateHud();
  }

  function gameOver(){
    state.gameOver=true;
    state.running=false;
    state.paused=false;

    state.best = Math.max(state.best, Math.floor(state.score));
    localStorage.setItem('minwoo_stage_best_v3', String(state.best));
    updateHud();

    panel.style.display='block';
    panel.innerHTML = `
      <b>ê²Œì„ ì˜¤ë²„ ğŸ˜µ</b>
      <div>ì ìˆ˜: <b>${Math.floor(state.score)}</b></div>
      <div>ìµœê³ : <b>${state.best}</b></div>
      <div style="margin-top:10px; font-weight:900;">í„°ì¹˜í•˜ë©´ ë‹¤ì‹œ ì‹œì‘</div>
      <small>(ë¯¼ìš°ë„ í•  ìˆ˜ ìˆëŠ” 1945 ğŸ™‚)</small>
    `;
  }

  function stageClear(){
    state.running=false;
    state.paused=false;

    if(state.stage >= MAX_STAGE){
      state.cleared=true;
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem('minwoo_stage_best_v3', String(state.best));
      updateHud();
      sfx.clear();
      panel.style.display='block';
      panel.innerHTML = `
        <b>ì „ì²´ í´ë¦¬ì–´! ğŸ‰</b>
        <div>10 ìŠ¤í…Œì´ì§€ ì™„ì£¼ ì„±ê³µ!</div>
        <div>ì ìˆ˜: <b>${Math.floor(state.score)}</b> / ìµœê³ : <b>${state.best}</b></div>
        <div style="margin-top:10px; font-weight:900;">í„°ì¹˜í•˜ë©´ ë‹¤ì‹œ(1ìŠ¤í…Œì´ì§€)</div>
        <small>(ì•„ë¹ ê°€ ë§Œë“  ê²Œì„ âœ…)</small>
      `;
      return;
    }

    const next = state.stage + 1;
    sfx.clear();
    panel.style.display='block';
    panel.innerHTML = `
      <b>ìŠ¤í…Œì´ì§€ ${state.stage} í´ë¦¬ì–´! âœ…</b>
      <div>ë‹¤ìŒ ìŠ¤í…Œì´ì§€: <b>${next}</b> (ë‚œì´ë„ ì™„ë§Œí•˜ê²Œ ì¦ê°€)</div>
      <div style="margin-top:10px; font-weight:900;">í„°ì¹˜í•˜ë©´ ì‹œì‘</div>
      <small>íŒŒì›Œì—…ì„ ëª¨ìœ¼ë©´ ë‹¤ìŒ ìŠ¤í…Œì´ì§€ê°€ ì‰¬ì›Œì§‘ë‹ˆë‹¤ ğŸ™‚</small>
    `;
    setStage(next);

    enemies.length=0; pBullets.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;
  }

  // ---------- Spawning ----------
  function spawnEnemy(){
    const size = rand(0,1);
    const w = size < 0.6 ? rand(28, 42) : rand(44, 58);
    const h = size < 0.6 ? rand(24, 34) : rand(34, 44);
    const x = rand(w/2 + 12, W - w/2 - 12);
    const y = -h - 10;
    const vy = state.enemySpeed * rand(0.85, 1.12);
    const hp = (w > 46) ? 5 : (Math.random() < 0.16 ? 3 : 2);
    const kind = (hp >= 5) ? 'elite' : (hp >= 3 ? 'heavy' : 'normal');

    enemies.push({
      x,y,w,h,vy,hp,
      shootCd: rand(0.35, 1.05),
      kind,
      wiggle: rand(0.5, 1.0),
      t0: rand(0, 10)
    });
  }

  function spawnBoss(){
    const w = Math.min(260, W * 0.66);
    const h = 110;
    const x = W * 0.5;
    const y = -h - 40;

    const hpMax = Math.floor((220 + state.stage*38) * state.diffMul);

    state.boss = {
      x,y,w,h,
      yStop: 118,
      vy: 120, // âœ… ë³´ìŠ¤ ë‚´ë ¤ì˜¤ëŠ” ì†ë„ë„ ì™„í™”
      dir: 1,
      speedX: 70 + 10*state.stage, // âœ… ì¢Œìš°ë„ ì™„í™”
      hp: hpMax,
      hpMax,
      shootTimer: 0,
      shootEvery: clamp(0.95 / state.diffMul, 0.45, 0.95), // âœ… ë³´ìŠ¤ ë°œì‚¬ë„ ì™„í™”
      patT: 0,
    };
    state.bossActive = true;
    sfx.boss();
    showToast(`ğŸ‘‘ ë³´ìŠ¤ ë“±ì¥! (Stage ${state.stage})`);
    if(navigator.vibrate) navigator.vibrate([30,30,30]);
  }

  // ---------- Player Shooting (íŒŒì›Œì—… ë°˜ì˜) ----------
  function getFireEvery(){
    // âœ… ì•„ì´ìš©: ê¸°ë³¸ ë°œì‚¬ë„ ë„ˆë¬´ ë¹ ë¥´ì§€ ì•Šê²Œ
    return clamp(0.18 - state.rapidLv*0.020, 0.10, 0.18);
  }

  function playerFire(){
    const baseVy = 860; // âœ… í”Œë ˆì´ì–´ íƒ„ì† ì™„í™”
    const spreadBase = 60 + state.wideLv * 32;
    const count = 1 + state.wideLv;
    const dmgBase = 1 + Math.floor(state.laserLv / 2);

    // normal bullets
    if(count === 1){
      pBullets.push({x: player.x, y: player.y - player.r - 8, vx: 0, vy: -baseVy, r: 3.1, damage: 1, type:'N', pierce:0});
    } else {
      for(let i=0;i<count;i++){
        const t = (i/(count-1) - 0.5);
        const vx = t * spreadBase * 2.2;
        pBullets.push({x: player.x + t*18, y: player.y - player.r - 8, vx, vy: -baseVy, r: 3.0, damage: 1, type:'N', pierce:0});
      }
    }

    // laser
    if(state.laserLv > 0){
      const pierce = state.laserLv;
      const dmg = 2 + dmgBase + state.laserLv;
      pBullets.push({x: player.x, y: player.y - player.r - 10, vx: 0, vy: -1180, r: 2.6, damage: dmg, type:'L', pierce});
      sfx.laser();
    } else {
      sfx.shoot();
    }
  }

  // ---------- Enemy Shooting ----------
  function enemyFireFrom(e){
    const base = 240 * state.diffMul; // âœ… ì  íƒ„ì† ì™„í™”
    const shots = (state.stage >= 7) ? 2 : 1;
    const spread = 90 + state.stage*7;

    if(shots === 1){
      eBullets.push({x:e.x, y:e.y + e.h*0.50, vx:0, vy: base, r:3.8, damage:1, kind:'dot'});
    } else {
      eBullets.push({x:e.x, y:e.y + e.h*0.50, vx:-spread, vy: base, r:3.6, damage:1, kind:'dot'});
      eBullets.push({x:e.x, y:e.y + e.h*0.50, vx: spread, vy: base, r:3.6, damage:1, kind:'dot'});
    }
    sfx.enemyShoot();
  }

  function bossFirePattern(){
    const b = state.boss;
    if(!b) return;

    const dm = state.diffMul;
    const baseVy = 260 * dm; // âœ… ë³´ìŠ¤ íƒ„ì† ì™„í™”
    const sx = 180;

    const addBullet = (x,y,vx,vy,r=4.0, kind='orb') => eBullets.push({x,y,vx,vy,r,damage:1,kind});
    const aimAtPlayer = (speed=360*dm) => {
      const dx = player.x - b.x;
      const dy = (player.y - b.y);
      const len = Math.max(1, Math.hypot(dx,dy));
      return { vx: (dx/len)*speed, vy: (dy/len)*speed };
    };

    b.patT += b.shootEvery;

    switch(state.stage){
      case 1: { // fan
        const n = 6;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*34, b.y + b.h*0.60, t*sx, baseVy, 4.0, 'orb');
        }
        break;
      }
      case 2: { // aimed 3-shot
        for(let k=0;k<3;k++){
          const a = aimAtPlayer(340*dm + k*14);
          addBullet(b.x, b.y + b.h*0.60, a.vx, a.vy, 4.2, 'orb');
        }
        break;
      }
      case 3: { // spiral
        const n = 7;
        const ang0 = b.patT * 1.10;
        for(let i=0;i<n;i++){
          const ang = ang0 + i*(Math.PI*2/n);
          addBullet(b.x, b.y + b.h*0.55, Math.cos(ang)*150*dm, baseVy + Math.sin(ang)*90*dm, 3.8, 'orb');
        }
        break;
      }
      case 4: { // wave
        const n = 6;
        const w = Math.sin(b.patT*1.0) * 0.8;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*56, b.y + b.h*0.58, (t*180 + w*170)*dm, baseVy, 4.0, 'orb');
        }
        break;
      }
      case 5: { // rain
        const n = 8;
        for(let i=0;i<n;i++){
          addBullet(b.x + rand(-b.w*0.33, b.w*0.33), b.y + b.h*0.62, rand(-55,55)*dm, baseVy + rand(0,90)*dm, 3.7, 'orb');
        }
        break;
      }
      case 6: { // cross + aimed
        for(let t of [-1, 1]){
          addBullet(b.x + t*46, b.y + b.h*0.60, t*170*dm, baseVy, 4.0, 'orb');
          addBullet(b.x + t*10, b.y + b.h*0.60, t*95*dm, baseVy+60*dm, 4.0, 'orb');
        }
        const a = aimAtPlayer(420*dm);
        addBullet(b.x, b.y + b.h*0.60, a.vx, a.vy, 4.4, 'orb');
        break;
      }
      case 7: { // alternating fan
        const n = 8;
        const dir = (Math.floor(b.patT*1.2) % 2 === 0) ? 1 : -1;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x, b.y + b.h*0.60, (t*sx*dir)*dm, baseVy, 3.9, 'orb');
        }
        break;
      }
      case 8: { // sweeping gap (í‹ˆ)
        const gapW = 160;
        const center = (Math.sin(b.patT*0.85)*0.5+0.5) * (W-gapW) + gapW/2;
        const n = 12;
        for(let i=0;i<n;i++){
          const x = (i/(n-1))*W;
          if(Math.abs(x-center) < gapW/2) continue;
          addBullet(x, b.y + b.h*0.62, 0, 280*dm, 3.9, 'orb');
        }
        break;
      }
      case 9: { // dense + needle
        const n = 10;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*86, b.y + b.h*0.60, t*150*dm, baseVy+50*dm, 3.7, 'orb');
        }
        const a = aimAtPlayer(520*dm);
        addBullet(b.x, b.y + b.h*0.58, a.vx, a.vy, 3.2, 'needle');
        break;
      }
      case 10: { // multi-phase
        const hpRatio = b.hp / b.hpMax;
        if(hpRatio > 0.66){
          const n = 8;
          const ang0 = b.patT * 1.25;
          for(let i=0;i<n;i++){
            const ang = ang0 + i*(Math.PI*2/n);
            addBullet(b.x, b.y + b.h*0.55, Math.cos(ang)*160*dm, baseVy + Math.sin(ang)*95*dm, 3.8, 'orb');
          }
        } else if(hpRatio > 0.33){
          const gapW = 170;
          const center = (Math.sin(b.patT*1.0)*0.5+0.5) * (W-gapW) + gapW/2;
          const n = 14;
          for(let i=0;i<n;i++){
            const x = (i/(n-1))*W;
            if(Math.abs(x-center) < gapW/2) continue;
            addBullet(x, b.y + b.h*0.62, 0, 300*dm, 3.9, 'orb');
          }
          const a = aimAtPlayer(560*dm);
          addBullet(b.x, b.y + b.h*0.58, a.vx, a.vy, 3.1, 'needle');
        } else {
          const n = 10;
          const dir = (Math.floor(b.patT*1.3) % 2 === 0) ? 1 : -1;
          for(let i=0;i<n;i++){
            const t = (i/(n-1)-0.5);
            addBullet(b.x, b.y + b.h*0.60, (t*220*dir)*dm, 320*dm, 3.8, 'orb');
          }
          for(let i=0;i<5;i++){
            addBullet(b.x + rand(-b.w*0.33, b.w*0.33), b.y + b.h*0.60, rand(-90,90)*dm, 320*dm, 3.6, 'orb');
          }
        }
        break;
      }
    }
    sfx.enemyShoot();
  }

  // ---------- Rendering ----------
  function drawBackground(dt){
    // âœ… ì•„ì´ëª¨ë“œ ì†ë„ ë°˜ì˜
    const scrollSpeed = (120 + 10*state.stage) * KID_SPEED;
    state.bgScroll = (state.bgScroll + scrollSpeed * dt) % H;

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#050713');
    g.addColorStop(0.55, '#070b18');
    g.addColorStop(1, '#04050b');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.26;
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<90;i++){
      const x = (i*97) % W;
      const y = ((i*163) + state.bgScroll) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = '#7db6ff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    const grid = 64;
    const off = state.bgScroll % grid;
    for(let y=-grid; y<H+grid; y+=grid){
      ctx.moveTo(0, y - off);
      ctx.lineTo(W, y - off);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawGlowCircle(x,y,r,inner,outer,alpha=1){
    ctx.save();
    ctx.globalAlpha = alpha;
    const rg = ctx.createRadialGradient(x,y,0,x,y,r);
    rg.addColorStop(0, inner);
    rg.addColorStop(1, outer);
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawPlayer(){
    const blink = (state.invuln>0 && Math.floor(state.t*14)%2===0);
    ctx.save();
    if(blink) ctx.globalAlpha=0.38;

    ctx.translate(player.x, player.y);

    const bg = ctx.createLinearGradient(0,-30,0,30);
    bg.addColorStop(0, '#f8fbff');
    bg.addColorStop(1, '#b7d6ff');
    ctx.fillStyle = bg;
    ctx.beginPath();
    ctx.moveTo(0, -28);
    ctx.lineTo(20, 26);
    ctx.lineTo(0, 14);
    ctx.lineTo(-20, 26);
    ctx.closePath();
    ctx.fill();

    const wg = ctx.createLinearGradient(-40,0,40,0);
    wg.addColorStop(0, '#1d55ff');
    wg.addColorStop(1, '#59a7ff');
    ctx.fillStyle = wg;
    ctx.beginPath(); ctx.moveTo(-20, 4); ctx.lineTo(-38, 18); ctx.lineTo(-10, 28); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(20, 4); ctx.lineTo(38, 18); ctx.lineTo(10, 28); ctx.closePath(); ctx.fill();

    drawGlowCircle(0,-6,14,'rgba(155,227,255,0.65)','rgba(155,227,255,0)',0.9);
    ctx.fillStyle = '#7db6ff';
    ctx.beginPath(); ctx.ellipse(0, -6, 7, 12, 0, 0, Math.PI*2); ctx.fill();

    if(state.running && !state.paused && !state.gameOver){
      const t = Math.sin(state.t*18)*3;
      drawGlowCircle(0, 34, 18, 'rgba(255,204,102,0.55)', 'rgba(255,204,102,0)', 0.9);
      ctx.fillStyle = '#ffcc66';
      ctx.beginPath();
      ctx.moveTo(0, 28);
      ctx.lineTo(8, 40 + t);
      ctx.lineTo(-8, 40 + t);
      ctx.closePath();
      ctx.fill();
    }

    ctx.restore();
  }

  function drawEnemy(e){
    ctx.save();
    ctx.translate(e.x, e.y);

    const g = ctx.createLinearGradient(0, -e.h, 0, e.h);
    g.addColorStop(0, '#2b3142');
    g.addColorStop(1, '#101421');
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.moveTo(0, -e.h*0.60);
    ctx.lineTo(e.w*0.55, e.h*0.55);
    ctx.lineTo(0, e.h*0.25);
    ctx.lineTo(-e.w*0.55, e.h*0.55);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#ff5a6b';
    ctx.beginPath(); ctx.moveTo(-e.w*0.18, -e.h*0.60); ctx.lineTo(-e.w*0.42, -e.h*0.85); ctx.lineTo(-e.w*0.06, -e.h*0.66); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(e.w*0.18, -e.h*0.60); ctx.lineTo(e.w*0.42, -e.h*0.85); ctx.lineTo(e.w*0.06, -e.h*0.66); ctx.closePath(); ctx.fill();

    drawGlowCircle(-e.w*0.14, -e.h*0.12, 10, 'rgba(255,90,107,0.65)', 'rgba(255,90,107,0)', 0.9);
    drawGlowCircle(e.w*0.14, -e.h*0.12, 10, 'rgba(255,90,107,0.65)', 'rgba(255,90,107,0)', 0.9);
    ctx.fillStyle = '#ff2f4f';
    ctx.beginPath(); ctx.arc(-e.w*0.14, -e.h*0.12, 3.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(e.w*0.14, -e.h*0.12, 3.2, 0, Math.PI*2); ctx.fill();

    if(e.kind==='elite'){
      drawGlowCircle(0, -e.h*0.05, 16, 'rgba(125,182,255,0.55)', 'rgba(125,182,255,0)', 0.9);
      ctx.fillStyle = '#7db6ff';
      ctx.beginPath(); ctx.ellipse(0, -e.h*0.05, 7, 10, 0, 0, Math.PI*2); ctx.fill();
    }

    ctx.restore();
  }

  function drawBoss(){
    const b = state.boss;
    if(!b) return;

    ctx.save();
    ctx.translate(b.x, b.y);

    const hg = ctx.createLinearGradient(0, -b.h, 0, b.h);
    hg.addColorStop(0, '#2a3246');
    hg.addColorStop(1, '#0f1323');
    ctx.fillStyle = hg;

    ctx.beginPath();
    ctx.moveTo(0, -b.h*0.60);
    ctx.lineTo(b.w*0.48, b.h*0.52);
    ctx.lineTo(0, b.h*0.18);
    ctx.lineTo(-b.w*0.48, b.h*0.52);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#ff5a6b';
    ctx.fillRect(-b.w*0.50, -b.h*0.08, b.w*0.16, b.h*0.34);
    ctx.fillRect(b.w*0.34, -b.h*0.08, b.w*0.16, b.h*0.34);

    drawGlowCircle(0, -b.h*0.08, 42, 'rgba(125,182,255,0.35)', 'rgba(125,182,255,0)', 1);
    ctx.fillStyle = '#7db6ff';
    ctx.beginPath(); ctx.ellipse(0, -b.h*0.08, 22, 14, 0, 0, Math.PI*2); ctx.fill();

    drawGlowCircle(-28, -b.h*0.16, 16, 'rgba(255,90,107,0.55)', 'rgba(255,90,107,0)', 1);
    drawGlowCircle(28, -b.h*0.16, 16, 'rgba(255,90,107,0.55)', 'rgba(255,90,107,0)', 1);
    ctx.fillStyle = '#ff2f4f';
    ctx.beginPath(); ctx.arc(-28, -b.h*0.16, 6, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(28, -b.h*0.16, 6, 0, Math.PI*2); ctx.fill();

    ctx.restore();

    const pad = 18;
    const barW = W - pad*2;
    const barH = 12;
    const ratio = clamp(b.hp / b.hpMax, 0, 1);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    ctx.fillRect(pad, 70, barW, barH);

    const col = (state.stage<=3) ? '#7db6ff' : (state.stage<=6 ? '#6dffb2' : (state.stage<=9 ? '#d993ff' : '#ffcc66'));
    ctx.fillStyle = col;
    ctx.fillRect(pad, 70, barW*ratio, barH);

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.strokeRect(pad, 70, barW, barH);
    ctx.globalAlpha = 1;
  }

  function drawBullets(){
    for(const m of pBullets){
      if(m.type==='L'){
        drawGlowCircle(m.x, m.y, 14, 'rgba(217,147,255,0.35)', 'rgba(217,147,255,0)', 1);
        ctx.fillStyle = '#d993ff';
        ctx.fillRect(m.x-1.5, m.y-14, 3, 16);
      } else {
        drawGlowCircle(m.x, m.y, 12, 'rgba(233,241,255,0.22)', 'rgba(233,241,255,0)', 1);
        ctx.fillStyle = '#e9f1ff';
        ctx.beginPath();
        ctx.roundRect(m.x-2.3, m.y-10, 4.6, 12, 3);
        ctx.fill();
      }
    }

    for(const b of eBullets){
      if(b.kind==='needle'){
        drawGlowCircle(b.x, b.y, 14, 'rgba(255,204,102,0.26)', 'rgba(255,204,102,0)', 1);
        ctx.fillStyle = '#ffcc66';
        ctx.fillRect(b.x-1.5, b.y-6, 3, 12);
      } else {
        drawGlowCircle(b.x, b.y, 14, 'rgba(255,204,102,0.18)', 'rgba(255,204,102,0)', 1);
        ctx.fillStyle = '#ffcc66';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  function drawPowerups(){
    for(const p of powerups){
      const col = (p.type==='WIDE') ? '#7db6ff' : (p.type==='RAPID' ? '#6dffb2' : '#d993ff');

      ctx.save();
      ctx.translate(p.x, p.y);

      // glow
      const glow = ctx.createRadialGradient(0,0,3,0,0,18);
      glow.addColorStop(0, col === '#7db6ff' ? 'rgba(125,182,255,0.55)'
                      : col === '#6dffb2' ? 'rgba(109,255,178,0.45)'
                      : 'rgba(217,147,255,0.45)');
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();

      // box
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.beginPath(); ctx.roundRect(-13, -13, 26, 26, 7); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.strokeRect(-13, -13, 26, 26);

      // ribbon
      ctx.fillStyle = col;
      ctx.fillRect(-2, -13, 4, 26);
      ctx.fillRect(-13, -2, 26, 4);

      // text
      ctx.fillStyle = '#0b1020';
      ctx.font = '900 9px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.type==='WIDE'?'W':(p.type==='RAPID'?'R':'L'), 0, 0);

      ctx.restore();
    }
  }

  function drawFx(){
    for(const r of rings){
      ctx.globalAlpha = clamp(r.life*3, 0, 1);
      ctx.strokeStyle = r.col;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.globalAlpha = 0.92;
    for(const p of sparks){
      ctx.fillStyle = p.col;
      ctx.fillRect(p.x, p.y, 3, 3);
    }
    ctx.globalAlpha = 1;
  }

  // ---------- Update ----------
  function update(dt){
    // âœ… ì•„ì´ëª¨ë“œ: ì „ì²´ ì‹œê°„ ìŠ¤ì¼€ì¼ ì ìš© (ê²Œì„ ì „ë°˜ ëŠë ¤ì§)
    dt *= KID_SPEED;

    state.t += dt;

    if(state.invuln>0) state.invuln = Math.max(0, state.invuln - dt);

    // move player
    const follow = 12; // âœ… ì‚´ì§ ë¶€ë“œëŸ½ê²Œ(ê³¼ì† ì´ë™ ë°©ì§€)
    if(player.targetX!==null){
      player.x += (player.targetX - player.x) * clamp(follow*dt, 0, 1);
      player.y += (player.targetY - player.y) * clamp(follow*dt, 0, 1);
    }
    player.x = clamp(player.x, player.r+10, W-player.r-10);
    player.y = clamp(player.y, player.r+10, H-player.r-10);

    // auto fire
    state._fireTimer = (state._fireTimer || 0) + dt;
    const fireEvery = getFireEvery();
    while(state._fireTimer >= fireEvery){
      state._fireTimer -= fireEvery;
      playerFire();
    }

    // spawn enemies only if boss not active
    if(!state.bossActive){
      state.enemySpawnTimer += dt;
      while(state.enemySpawnTimer >= state.enemySpawnEvery){
        state.enemySpawnTimer -= state.enemySpawnEvery;
        spawnEnemy();
      }
    }

    // update enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      e.y += e.vy * dt;

      e.t0 += dt * e.wiggle;
      e.x += Math.sin(e.t0) * 18 * dt * state.diffMul; // âœ… í”ë“¤ë¦¼ ì™„í™”
      e.x = clamp(e.x, e.w/2+10, W-e.w/2-10);

      e.shootCd -= dt;
      if(e.shootCd <= 0 && !state.bossActive){
        e.shootCd = rand(0.55, 1.25) * state.enemyFireEvery; // âœ… ë” ì²œì²œíˆ
        enemyFireFrom(e);
      }

      if(circleHit(player.x, player.y, player.r*0.90, e.x, e.y, Math.max(e.w,e.h)*0.34)){
        onPlayerHit(1);
      }

      if(e.y - e.h > H + 60){
        enemies.splice(i,1);
      }
    }

    // boss logic
    if(state.bossActive){
      const b = state.boss;

      if(b.y < b.yStop){
        b.y += b.vy * dt;
        if(b.y > b.yStop) b.y = b.yStop;
      } else {
        b.x += b.dir * b.speedX * dt;
        const left = b.w*0.30;
        const right = W - b.w*0.30;
        if(b.x < left){ b.x = left; b.dir = 1; }
        if(b.x > right){ b.x = right; b.dir = -1; }

        b.shootTimer += dt;
        if(b.shootTimer >= b.shootEvery){
          b.shootTimer = 0;
          bossFirePattern();
        }
      }

      if(circleHit(player.x, player.y, player.r*0.90, b.x, b.y, Math.min(b.w,b.h)*0.55)){
        onPlayerHit(1);
      }
    }

    // update player bullets
    for(let i=pBullets.length-1;i>=0;i--){
      const m = pBullets[i];
      m.x += m.vx * dt;
      m.y += m.vy * dt;

      if(m.y < -60 || m.x < -60 || m.x > W+60) pBullets.splice(i,1);
    }

    // update enemy bullets
    for(let i=eBullets.length-1;i>=0;i--){
      const b = eBullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      if(circleHit(player.x, player.y, player.r*0.85, b.x, b.y, b.r)){
        eBullets.splice(i,1);
        onPlayerHit(1);
        continue;
      }
      if(b.y > H + 80 || b.x < -80 || b.x > W+80) eBullets.splice(i,1);
    }

    // bullets vs enemies
    for(let ei=enemies.length-1; ei>=0; ei--){
      const e = enemies[ei];

      for(let bi=pBullets.length-1; bi>=0; bi--){
        const m = pBullets[bi];
        const er = Math.max(e.w,e.h)*0.34;
        if(circleHit(m.x, m.y, m.r+2, e.x, e.y, er)){
          e.hp -= m.damage;

          if(m.type==='L' && m.pierce>0){
            m.pierce -= 1;
          } else {
            pBullets.splice(bi,1);
          }

          boom(m.x, m.y, 4, m.type==='L' ? '#d993ff' : '#ffcc66');

          if(e.hp <= 0){
            state.score += (e.kind==='elite' ? 120 : (e.kind==='heavy' ? 70 : 45)) * state.diffMul;
            state.kills += 1;
            boom(e.x, e.y, e.kind==='elite' ? 28 : 18, '#ffcc66');
            dropPowerup(e.x, e.y);
            enemies.splice(ei,1);
          }
          break;
        }
      }
    }

    // bullets vs boss
    if(state.bossActive && state.boss){
      const b = state.boss;
      const br = Math.min(b.w,b.h)*0.55;

      for(let bi=pBullets.length-1; bi>=0; bi--){
        const m = pBullets[bi];
        if(circleHit(m.x, m.y, m.r+2, b.x, b.y, br)){
          b.hp -= m.damage;

          if(m.type==='L' && m.pierce>0){
            m.pierce -= 1;
          } else {
            pBullets.splice(bi,1);
          }

          boom(m.x, m.y, 4, m.type==='L' ? '#d993ff' : '#7db6ff');

          if(b.hp <= 0){
            state.score += 1200 * state.diffMul;
            boom(b.x, b.y, 60, '#ffcc66');
            state.bossActive = false;
            state.boss = null;
            enemies.length=0;
            eBullets.length=0;
            powerups.length=0;
            stageClear();
          }
          break;
        }
      }
    }

    // update powerups
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      p.y += p.vy * dt;

      if(circleHit(player.x, player.y, player.r*0.95, p.x, p.y, p.r)){
        powerups.splice(i,1);
        applyPowerup(p.type);
        continue;
      }
      if(p.y > H + 60) powerups.splice(i,1);
    }

    // FX update
    for(let i=sparks.length-1;i>=0;i--){
      const p = sparks[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.90;
      p.vy *= 0.90;
      if(p.life<=0) sparks.splice(i,1);
    }
    for(let i=rings.length-1;i>=0;i--){
      const r = rings[i];
      r.life -= dt;
      r.r += r.vr * dt;
      r.vr *= 0.92;
      if(r.life<=0) rings.splice(i,1);
    }

    // stage boss trigger
    if(!state.bossActive && state.kills >= state.killsToBoss){
      enemies.length=0;
      eBullets.length=0;
      spawnBoss();
    }

    // score over time (ì•„ì´ìš©: ì ìˆ˜ ìƒìŠ¹ë„ ì‚´ì§ ì™„í™”)
    state.score += dt * (8 * state.diffMul);
    updateHud();
  }

  function loop(ts){
    requestAnimationFrame(loop);
    if(!state.lastTs) state.lastTs = ts;
    const dt = Math.min(0.033, (ts - state.lastTs)/1000);
    state.lastTs = ts;

    // âœ… ê¹¨ì§ ë°©ì§€ í•µì‹¬: ë§¤ í”„ë ˆì„ ë³€í™˜ ì´ˆê¸°í™”
    ctx.setTransform(DPR,0,0,DPR,0,0);

    drawBackground(dt);

    if(state.running && !state.paused && !state.gameOver){
      update(dt);
    }

    drawPowerups();
    for(const e of enemies) drawEnemy(e);
    if(state.bossActive) drawBoss();
    drawBullets();
    drawFx();
    drawPlayer();

    if(state.paused && !state.gameOver){
      ctx.fillStyle='rgba(0,0,0,0.40)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff';
      ctx.font='900 28px system-ui';
      ctx.textAlign='center';
      ctx.fillText('ì¼ì‹œì •ì§€', W/2, H/2);
      ctx.font='700 14px system-ui';
      ctx.fillText('ì˜¤ë¥¸ìª½ ìœ„ "ì¬ê°œ"ë¥¼ ëˆ„ë¥´ì„¸ìš”', W/2, H/2 + 28);
    }
  }

  // init
  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
