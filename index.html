<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#070a14" />
  <title>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ…</title>
  <link rel="manifest" href="manifest.json" />
  <style>
    html, body { margin:0; height:100%; background:#070a14; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; }
    #wrap { position: relative; width:100%; height:100%; }
    canvas { width:100%; height:100%; display:block; touch-action:none; }

    .hud{
      position:absolute; left:12px; top:12px;
      color:#fff; font-weight:900; font-size:13.5px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.75);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      max-width: calc(100% - 170px);
      pointer-events:none;
    }
    .hud span{
      opacity:0.95; padding:6px 10px; border-radius:14px;
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.08);
    }
    .btns{ position:absolute; right:12px; top:12px; display:flex; gap:8px; }
    button{
      appearance:none; border:0; border-radius:14px; padding:10px 12px;
      font-weight:900; background:rgba(255,255,255,0.12); color:#fff; backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.08);
    }
    button:active{ transform: translateY(1px); }

    .panel{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      color:#fff; text-align:center;
      padding:14px 16px; border-radius:18px;
      background:rgba(0,0,0,0.48);
      width:min(560px, 92vw);
      line-height:1.4;
      box-shadow: 0 14px 40px rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .panel b{ font-size:18px; display:block; margin-bottom:10px; }
    .panel small{ opacity:0.92; display:block; margin-top:10px; }

    .toast{
      position:absolute; left:50%; bottom:18px;
      transform:translateX(-50%);
      color:#fff; font-weight:900;
      background: rgba(0,0,0,0.55);
      padding:10px 12px; border-radius:14px;
      opacity:0; pointer-events:none;
      transition: opacity 160ms ease;
      border:1px solid rgba(255,255,255,0.08);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    }
    .toast.show{ opacity:1; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <span id="stage">ìŠ¤í…Œì´ì§€: 1/20</span>
    <span id="score">ì ìˆ˜: 0</span>
    <span id="best">ìµœê³ : 0</span>
    <span id="life">ëª©ìˆ¨: 10</span>
    <span id="pow">íŒŒì›Œì—…: W0 R0 L0</span>
    <span id="sub">ì„œë¸Œì›¨í°: OFF</span>
  </div>

  <div class="btns">
    <button id="soundBtn">ì‚¬ìš´ë“œ ON</button>
    <button id="pauseBtn">ì¼ì‹œì •ì§€</button>
    <button id="restartBtn">ì¬ì‹œì‘</button>
  </div>

  <div id="panel" class="panel">
    <b>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ… âœˆï¸</b>
    <div>í™”ë©´ì„ <b>í„°ì¹˜í•´ì„œ ë“œë˜ê·¸</b>í•˜ë©´ ë¹„í–‰ê¸°ê°€ ì›€ì§ì—¬ìš”.</div>
    <div>ğŸ”« ìë™ë°œì‚¬ / ğŸ íŒŒì›Œì—… 3ì¢… / ğŸ‘‘ 20ìŠ¤í…Œì´ì§€ ë³´ìŠ¤</div>
    <div style="margin-top:10px; font-weight:900;">íŒŒì›Œì—… 3ì¢…</div>
    <div>ğŸŸ¦ WIDE(ì™€ì´ë“œ) / ğŸŸ© RAPID(ì—°ì‚¬) / ğŸŸª LASER(ë ˆì´ì €)</div>
    <div style="margin-top:6px;">âœ… íŒŒì›Œì—… ì´í•©ì´ <b>10</b> ì´ìƒì´ë©´ <b>ì„œë¸Œì›¨í°</b>ì´ ì¼œì ¸ìš”!</div>
    <small>(ì•„ë¬´ ê³³ì´ë‚˜ í„°ì¹˜í•˜ë©´ ì‹œì‘)</small>
  </div>

  <div id="toast" class="toast">POWER UP!</div>
</div>

<script>
(() => {
  // ============================
  // âœ… ê¸°ë³¸ ì„¤ì •
  // ============================
  const KID_SPEED = 0.75;     // ì•„ì´ìš© ì†ë„ (0.70 ë” ëŠë¦¼ / 0.80 ì¡°ê¸ˆ ë¹ ë¦„)
  const STAGE_GROWTH = 1.07;  // ë‚œì´ë„ ì™„ë§Œ ì¦ê°€
  const MAX_STAGE = 20;

  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
  }

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  const elStage = document.getElementById('stage');
  const elScore = document.getElementById('score');
  const elBest  = document.getElementById('best');
  const elLife  = document.getElementById('life');
  const elPow   = document.getElementById('pow');
  const elSub   = document.getElementById('sub');

  const panel = document.getElementById('panel');
  const toast = document.getElementById('toast');

  const soundBtn = document.getElementById('soundBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  let W=0, H=0, DPR=1;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- Sound ----------
  let audioEnabled = true;
  soundBtn.textContent = 'ì‚¬ìš´ë“œ ON';

  function beep(freq=440, dur=0.06, type='sine', gain=0.06) {
    if (!audioEnabled) return;
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) return;
    const ac = beep._ac || (beep._ac = new AudioCtx());
    if (ac.state === 'suspended') ac.resume().catch(()=>{});
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = gain;
    o.connect(g); g.connect(ac.destination);
    const t = ac.currentTime;
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.start(t); o.stop(t + dur);
  }
  const sfx = {
    start(){ beep(660,0.06,'triangle',0.06); beep(880,0.06,'triangle',0.05); },
    shoot(){ beep(780,0.03,'square',0.040); },
    sub(){ beep(920,0.03,'square',0.028); },
    laser(){ beep(980,0.04,'sawtooth',0.040); },
    hit(){ beep(140,0.10,'sawtooth',0.075); },
    boom(){ beep(220,0.06,'square',0.06); beep(110,0.10,'sawtooth',0.05); },
    power(){ beep(980,0.06,'triangle',0.08); beep(1320,0.06,'triangle',0.06); },
    enemyShoot(){ beep(420,0.04,'sine',0.028); },
    boss(){ beep(240,0.12,'square',0.07); beep(180,0.14,'square',0.05); },
    bossHit(){ beep(520,0.03,'sine',0.035); },
    clear(){ beep(880,0.08,'triangle',0.07); beep(1320,0.10,'triangle',0.06); beep(1760,0.12,'triangle',0.05); }
  };

  soundBtn.addEventListener('click', () => {
    audioEnabled = !audioEnabled;
    soundBtn.textContent = audioEnabled ? 'ì‚¬ìš´ë“œ ON' : 'ì‚¬ìš´ë“œ OFF';
    beep(440,0.04,'sine',0.04);
  });

  function showToast(text){
    toast.textContent = text;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 560);
  }

  // ---------- Game State ----------
  const state = {
    running:false, paused:false, gameOver:false, cleared:false,
    t:0, lastTs:0,

    stage:1,
    score:0,
    best:Number(localStorage.getItem('minwoo_stage_best_v5') || 0),

    lives:10,
    invuln:0,

    // powerups (ë¬´í•œì„±ì¥ ìœ ì§€)
    wideLv:0,
    rapidLv:0,
    laserLv:0,

    subWeapon:false,

    bgScroll:0,

    kills:0,
    killsToBoss: 28,
    bossActive:false,

    diffMul: 1.0,

    enemySpawnTimer:0,
    enemySpawnEvery:0.72,
    enemySpeed: 185,
    enemyFireEvery:1.25,

    boss:null,
    _fireTimer:0,
    _subTimer:0,
  };

  function powerSum(){
    return state.wideLv + state.rapidLv + state.laserLv;
  }

  function updateHud(){
    elStage.textContent = `ìŠ¤í…Œì´ì§€: ${state.stage}/${MAX_STAGE}`;
    elScore.textContent = `ì ìˆ˜: ${Math.floor(state.score)}`;
    elBest.textContent  = `ìµœê³ : ${state.best}`;
    elLife.textContent  = `ëª©ìˆ¨: ${state.lives}`;
    elPow.textContent   = `íŒŒì›Œì—…: W${state.wideLv} R${state.rapidLv} L${state.laserLv}`;
    elSub.textContent   = `ì„œë¸Œì›¨í°: ${state.subWeapon ? 'ON' : 'OFF'}`;
  }
  updateHud();

  // ---------- Objects ----------
  const player = { x: W*0.5, y: H*0.82, r:18, targetX:null, targetY:null };
  const enemies = [];        // {x,y,w,h,vy,hp,shootCd,kind,wiggle,t0,carrier,sparkT}
  const pBullets = [];       // {x,y,vx,vy,r,damage,type,pierce,curve,from}
  const eBullets = [];       // {x,y,vx,vy,r,damage,kind, spawnDelay, life}
  const powerups = [];       // {x,y,vy,r,type}
  const sparks = [];         // {x,y,vx,vy,life,col}
  const rings  = [];         // {x,y,r,vr,life,col}

  // ---------- Controls ----------
  let isPointerDown=false;
  function pointerPos(e){
    const rect = canvas.getBoundingClientRect();
    return { x: (e.clientX-rect.left), y:(e.clientY-rect.top) };
  }
  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    isPointerDown=true;
    const p = pointerPos(e);

    if(!state.running && !state.gameOver && !state.cleared){
      state.running=true; panel.style.display='none'; sfx.start();
    } else if(state.gameOver || state.cleared){
      resetGame();
      state.running=true; panel.style.display='none'; sfx.start();
    }

    player.targetX=p.x; player.targetY=p.y;
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!isPointerDown) return;
    const p = pointerPos(e);
    player.targetX=p.x; player.targetY=p.y;
  });
  canvas.addEventListener('pointerup', ()=>{
    isPointerDown=false;
    player.targetX=null; player.targetY=null;
  });

  pauseBtn.addEventListener('click', ()=>{
    if(!state.running && !state.gameOver) return;
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? 'ì¬ê°œ' : 'ì¼ì‹œì •ì§€';
    beep(300,0.04,'sine',0.04);
  });

  restartBtn.addEventListener('click', ()=>{
    resetGame();
    state.running=true;
    panel.style.display='none';
    sfx.start();
  });

  // ---------- Helpers ----------
  function circleHit(ax,ay,ar,bx,by,br){
    const dx=ax-bx, dy=ay-by;
    const rr=ar+br;
    return (dx*dx+dy*dy) <= rr*rr;
  }

  function boom(x,y,amount=18, col='#ffcc66'){
    for(let i=0;i<amount;i++){
      const a = rand(0, Math.PI*2);
      const sp = rand(70, 340);
      sparks.push({x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.18,0.55), col});
    }
    rings.push({x,y, r: 6, vr: rand(220, 420), life: rand(0.18, 0.32), col});
    sfx.boom();
    if(navigator.vibrate) navigator.vibrate(10);
  }

  function bossHitFx(x,y){
    // âœ… ë³´ìŠ¤ í”¼ê²© ì´í™íŠ¸: ë²ˆì© + ë§ + ì§§ì€ ì‚¬ìš´ë“œ
    rings.push({x,y, r: 10, vr: 520, life: 0.20, col: '#ffffff'});
    rings.push({x,y, r: 6, vr: 420, life: 0.18, col: '#7db6ff'});
    sfx.bossHit();
    if(state.boss) state.boss.hitFlash = 0.12;
  }

  function onPlayerHit(dmg=1){
    if(state.invuln>0) return;
    state.lives -= dmg;
    state.invuln = 1.10;
    sfx.hit();
    if(navigator.vibrate) navigator.vibrate(60);
    updateHud();

    if(state.lives<=0){
      gameOver();
    } else {
      showToast(`-1 ëª©ìˆ¨! (ë‚¨ì€ ${state.lives})`);
    }
  }

  function applyPowerup(type){
    if(type==='WIDE')  state.wideLv += 1;
    if(type==='RAPID') state.rapidLv += 1;
    if(type==='LASER') state.laserLv += 1;

    sfx.power();
    showToast(`POWER UP! (í•©:${powerSum()})`);

    // âœ… íŒŒì›Œì—… í•© 10 ì´ìƒì´ë©´ ì„œë¸Œì›¨í° ON
    const was = state.subWeapon;
    state.subWeapon = (powerSum() >= 10);
    if(!was && state.subWeapon){
      showToast('ì„œë¸Œì›¨í° ON!');
      if(navigator.vibrate) navigator.vibrate([30,30,30]);
    }
    updateHud();
  }

  function dropPowerup(x,y){
    const r = Math.random();
    let type = 'WIDE';
    if(r < 0.34) type = 'WIDE';
    else if(r < 0.68) type = 'RAPID';
    else type = 'LASER';
    powerups.push({x,y, vy: 115 * state.diffMul, r: 12, type});
  }

  // ---------- Stage / Difficulty ----------
  function setStage(n){
    state.stage = n;
    state.kills = 0;
    state.bossActive = false;
    state.boss = null;

    state.diffMul = Math.pow(STAGE_GROWTH, state.stage - 1);

    state.enemySpeed = 185 * state.diffMul;
    state.enemySpawnEvery = clamp((0.74 / state.diffMul), 0.34, 0.95);
    state.enemyFireEvery  = clamp((1.30 / state.diffMul), 0.60, 1.55);

    state.killsToBoss = Math.floor(24 + state.stage * 4);

    enemies.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;

    updateHud();
  }

  function resetGame(){
    state.running=false; state.paused=false; state.gameOver=false; state.cleared=false;
    state.t=0; state.bgScroll=0;
    state.score=0;
    state.lives=10;
    state.invuln=0;

    state.wideLv=0; state.rapidLv=0; state.laserLv=0;
    state.subWeapon=false;

    enemies.length=0; pBullets.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;

    player.x=W*0.5; player.y=H*0.82;
    player.targetX=null; player.targetY=null;

    state.enemySpawnTimer=0;
    state._fireTimer=0;
    state._subTimer=0;

    setStage(1);

    panel.style.display='block';
    panel.innerHTML = `
      <b>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ… âœˆï¸</b>
      <div>ë“œë˜ê·¸ ì´ë™ / ìë™ë°œì‚¬ / 20ìŠ¤í…Œì´ì§€</div>
      <div style="margin-top:8px; font-weight:900;">âœ¨ ë°˜ì§ì´ëŠ” ì  = ì•„ì´í…œ í™•ë¥  â†‘</div>
      <div>íŒŒì›Œì—… í•© 10 ì´ìƒì´ë©´ <b>ì„œë¸Œì›¨í° ON</b></div>
      <small>(í„°ì¹˜í•˜ë©´ ì‹œì‘)</small>
    `;
    pauseBtn.textContent='ì¼ì‹œì •ì§€';
    updateHud();
  }

  function gameOver(){
    state.gameOver=true;
    state.running=false;
    state.paused=false;

    state.best = Math.max(state.best, Math.floor(state.score));
    localStorage.setItem('minwoo_stage_best_v5', String(state.best));
    updateHud();

    panel.style.display='block';
    panel.innerHTML = `
      <b>ê²Œì„ ì˜¤ë²„ ğŸ˜µ</b>
      <div>ì ìˆ˜: <b>${Math.floor(state.score)}</b></div>
      <div>ìµœê³ : <b>${state.best}</b></div>
      <div style="margin-top:10px; font-weight:900;">í„°ì¹˜í•˜ë©´ ë‹¤ì‹œ ì‹œì‘</div>
    `;
  }

  function stageClear(){
    state.running=false;
    state.paused=false;

    if(state.stage >= MAX_STAGE){
      state.cleared=true;
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem('minwoo_stage_best_v5', String(state.best));
      updateHud();
      sfx.clear();
      panel.style.display='block';
      panel.innerHTML = `
        <b>ì „ì²´ í´ë¦¬ì–´! ğŸ‰</b>
        <div>20 ìŠ¤í…Œì´ì§€ ì™„ì£¼ ì„±ê³µ!</div>
        <div>ì ìˆ˜: <b>${Math.floor(state.score)}</b> / ìµœê³ : <b>${state.best}</b></div>
        <div style="margin-top:10px; font-weight:900;">í„°ì¹˜í•˜ë©´ ë‹¤ì‹œ(1ìŠ¤í…Œì´ì§€)</div>
      `;
      return;
    }

    const next = state.stage + 1;
    sfx.clear();
    panel.style.display='block';
    panel.innerHTML = `
      <b>ìŠ¤í…Œì´ì§€ ${state.stage} í´ë¦¬ì–´! âœ…</b>
      <div>ë‹¤ìŒ ìŠ¤í…Œì´ì§€: <b>${next}</b></div>
      <div style="margin-top:10px; font-weight:900;">í„°ì¹˜í•˜ë©´ ì‹œì‘</div>
    `;
    setStage(next);

    enemies.length=0; pBullets.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;
  }

  // ---------- Spawning ----------
  function spawnEnemy(){
    const size = rand(0,1);
    const w = size < 0.6 ? rand(28, 42) : rand(44, 58);
    const h = size < 0.6 ? rand(24, 34) : rand(34, 44);
    const x = rand(w/2 + 12, W - w/2 - 12);
    const y = -h - 10;
    const vy = (185 * state.diffMul) * rand(0.85, 1.12);
    const hp = (w > 46) ? 5 : (Math.random() < 0.16 ? 3 : 2);
    const kind = (hp >= 5) ? 'elite' : (hp >= 3 ? 'heavy' : 'normal');

    const carrierChance = 0.22;
    const carrier = Math.random() < carrierChance;

    enemies.push({
      x,y,w,h,vy,hp,
      shootCd: rand(0.55, 1.20),
      kind,
      wiggle: rand(0.5, 1.0),
      t0: rand(0, 10),
      carrier,
      sparkT: rand(0, 10)
    });
  }

  function spawnBoss(){
    const w = Math.min(280, W * 0.70);
    const h = 120;
    const x = W * 0.5;
    const y = -h - 40;

    // ìŠ¤í…Œì´ì§€ 20 ê¸°ì¤€ìœ¼ë¡œ ì ì  ê°•í•´ì§
    const hpMax = Math.floor((320 + state.stage*60) * state.diffMul * 1.25);

    state.boss = {
      x,y,w,h,
      yStop: 118,
      vy: 120,
      dir: 1,
      speedX: 85 + 10*state.stage,
      hp: hpMax,
      hpMax,
      shootTimer: 0,
      shootEvery: clamp(0.85 / state.diffMul, 0.28, 0.85),
      patT: 0,
      hitFlash: 0, // âœ… í”¼ê²© ë²ˆì©
    };
    state.bossActive = true;
    sfx.boss();
    showToast(`ğŸ‘‘ ë³´ìŠ¤ ë“±ì¥! (Stage ${state.stage})`);
    if(navigator.vibrate) navigator.vibrate([30,30,30]);
  }

  // ---------- Shooting ----------
  function getFireEvery(){
    return clamp(0.18 - state.rapidLv*0.010, 0.08, 0.18);
  }

  function playerFire(){
    const baseVy = 900;
    const count = 1 + Math.min(10, state.wideLv);
    const spreadBase = 70 + Math.min(12, state.wideLv) * 24;

    const pSum = powerSum();
    const curvePow = Math.max(0, pSum - 8);
    const curveBase = Math.min(2.4, curvePow * 0.10);

    // ë©”ì¸íƒ„
    if(count === 1){
      pBullets.push({x: player.x, y: player.y - player.r - 8, vx: 0, vy: -baseVy, r: 3.1, damage: 1, type:'N', pierce:0, curve: (Math.random()<0.5?-1:1)*curveBase, from:'main'});
    } else {
      for(let i=0;i<count;i++){
        const t = (i/(count-1) - 0.5);
        const vx = t * spreadBase * 2.2;
        pBullets.push({
          x: player.x + t*18,
          y: player.y - player.r - 8,
          vx, vy: -baseVy,
          r: 3.0, damage: 1,
          type:'N', pierce:0,
          curve: (t===0? (Math.random()<0.5?-1:1) : Math.sign(t)) * curveBase * 0.85,
          from:'main'
        });
      }
    }

    // ë ˆì´ì €
    if(state.laserLv > 0){
      const pierce = Math.min(20, state.laserLv);
      const dmg = 2 + Math.floor(state.laserLv/2) + Math.min(10, state.laserLv);
      pBullets.push({x: player.x, y: player.y - player.r - 10, vx: 0, vy: -1200, r: 2.6, damage: dmg, type:'L', pierce, curve: 0, from:'main'});
      sfx.laser();
    } else {
      sfx.shoot();
    }
  }

  // âœ… ì„œë¸Œì›¨í°(íŒŒì›Œí•© 10 ì´ìƒ)
  function subWeaponFire(){
    const y = player.y - player.r - 6;
    const leftX  = player.x - 34;
    const rightX = player.x + 34;

    // ì„œë¸Œì›¨í° ë ˆë²¨(íŒŒì›Œê°€ ë” ì˜¬ë¼ê°€ë©´ ì•½ê°„ ê°•í™”)
    const lvl = Math.floor((powerSum() - 10) / 5); // 10~14:0, 15~19:1 ...
    const dmg = 1 + Math.min(3, lvl);
    const spd = -980;

    // ì‚´ì§ ëª¨ì´ëŠ” ê°ë„(ì„íŒ©íŠ¸)
    pBullets.push({x:leftX,  y, vx: -40, vy: spd, r: 2.7, damage: dmg, type:'S', pierce:0, curve: 0, from:'sub'});
    pBullets.push({x:rightX, y, vx:  40, vy: spd, r: 2.7, damage: dmg, type:'S', pierce:0, curve: 0, from:'sub'});
    sfx.sub();
  }

  // âœ… ì  íƒ„: ìœ ë„ ì—†ìŒ. "í”Œë ˆì´ì–´ë¥¼ í–¥í•´ í•œ ë²ˆ ì¡°ì¤€" í›„ ì§ì„  ì§„í–‰
  function enemyFireFrom(e){
    const speed = 280 * state.diffMul;
    const baseDelay = 0.14; // 3ë°œ ê°„ê²©(ì²œì²œíˆ)
    const shots = 3;

    // ì¡°ì¤€ ê°ë„(í•œ ë²ˆë§Œ ê³„ì‚°)
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const len = Math.max(1, Math.hypot(dx,dy));
    const ax = (dx/len) * speed;
    const ay = (dy/len) * speed;

    // ë„ˆë¬´ ì˜†ìœ¼ë¡œ íŠ€ë©´ ê²Œì„ì´ ì–´ë ¤ì›Œì§€ë‹ˆ Xì†ë„ ì œí•œ
    const vx0 = clamp(ax, -220*state.diffMul, 220*state.diffMul);
    const vy0 = Math.max(180*state.diffMul, ay);

    for(let i=0;i<shots;i++){
      eBullets.push({
        x: e.x, y: e.y + e.h*0.55,
        vx: vx0, vy: vy0,
        r: 4.0, damage: 1,
        kind: 'aim',
        spawnDelay: i * baseDelay,
        life: 6.0
      });
    }
    sfx.enemyShoot();
  }

  // ë³´ìŠ¤ íŒ¨í„´: 10ê°œ íŒ¨í„´ì„ 20ìŠ¤í…Œì´ì§€ì—ì„œ 2ë°”í€´(11~20ì€ ê°•í™”)
  function bossFirePattern(){
    const b = state.boss;
    if(!b) return;

    const dm = state.diffMul;
    const cycle = ((state.stage - 1) % 10) + 1;     // 1~10
    const tier = (state.stage > 10) ? 1.15 : 1.00;  // 11~20 ê°•í™”

    const baseVy = 320 * dm * tier;
    const sx = 240 * tier;

    const addBullet = (x,y,vx,vy,r=4.0, kind='orb') =>
      eBullets.push({x,y,vx,vy,r,damage:1,kind, spawnDelay:0, life:8.0});

    const aimAtPlayer = (speed=460*dm*tier) => {
      const dx = player.x - b.x;
      const dy = (player.y - b.y);
      const len = Math.max(1, Math.hypot(dx,dy));
      return { vx: (dx/len)*speed, vy: (dy/len)*speed };
    };

    b.patT += b.shootEvery;

    switch(cycle){
      case 1: { // fan
        const n = 8;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*36, b.y + b.h*0.60, t*sx, baseVy, 4.0, 'orb');
        }
        break;
      }
      case 2: { // aimed burst
        const kmax = (tier>1 ? 5 : 4);
        for(let k=0;k<kmax;k++){
          const a = aimAtPlayer(480*dm*tier + k*18);
          addBullet(b.x, b.y + b.h*0.60, a.vx, a.vy, 4.2, 'orb');
        }
        break;
      }
      case 3: { // spiral
        const n = 10;
        const ang0 = b.patT * 1.15;
        for(let i=0;i<n;i++){
          const ang = ang0 + i*(Math.PI*2/n);
          addBullet(b.x, b.y + b.h*0.55, Math.cos(ang)*200*dm*tier, baseVy + Math.sin(ang)*130*dm*tier, 3.8, 'orb');
        }
        break;
      }
      case 4: { // wave
        const n = 9;
        const w = Math.sin(b.patT*1.0) * 1.0;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*58, b.y + b.h*0.58, (t*240 + w*220)*dm*tier, baseVy, 4.0, 'orb');
        }
        break;
      }
      case 5: { // rain
        const n = tier>1 ? 12 : 10;
        for(let i=0;i<n;i++){
          addBullet(b.x + rand(-b.w*0.33, b.w*0.33), b.y + b.h*0.62, rand(-80,80)*dm*tier, baseVy + rand(0,140)*dm*tier, 3.7, 'orb');
        }
        break;
      }
      case 6: { // cross + aimed
        for(let t of [-1, 1]){
          addBullet(b.x + t*46, b.y + b.h*0.60, t*220*dm*tier, baseVy, 4.0, 'orb');
          addBullet(b.x + t*12, b.y + b.h*0.60, t*140*dm*tier, baseVy+90*dm*tier, 4.0, 'orb');
        }
        const a = aimAtPlayer(520*dm*tier);
        addBullet(b.x, b.y + b.h*0.60, a.vx, a.vy, 4.4, 'orb');
        break;
      }
      case 7: { // alternating fan
        const n = 11;
        const dir = (Math.floor(b.patT*1.2) % 2 === 0) ? 1 : -1;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x, b.y + b.h*0.60, (t*sx*dir)*dm, baseVy, 3.9, 'orb');
        }
        break;
      }
      case 8: { // gap wall
        const gapW = tier>1 ? 170 : 190;
        const center = (Math.sin(b.patT*0.85)*0.5+0.5) * (W-gapW) + gapW/2;
        const n = tier>1 ? 16 : 14;
        for(let i=0;i<n;i++){
          const x = (i/(n-1))*W;
          if(Math.abs(x-center) < gapW/2) continue;
          addBullet(x, b.y + b.h*0.62, 0, 360*dm*tier, 3.9, 'orb');
        }
        break;
      }
      case 9: { // dense + needle
        const n = tier>1 ? 14 : 12;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*86, b.y + b.h*0.60, t*190*dm*tier, baseVy+90*dm*tier, 3.7, 'orb');
        }
        const a = aimAtPlayer(600*dm*tier);
        addBullet(b.x, b.y + b.h*0.58, a.vx, a.vy, 3.2, 'needle');
        break;
      }
      case 10: { // phase
        const hpRatio = b.hp / b.hpMax;
        if(hpRatio > 0.66){
          const n = 10;
          const ang0 = b.patT * 1.25;
          for(let i=0;i<n;i++){
            const ang = ang0 + i*(Math.PI*2/n);
            addBullet(b.x, b.y + b.h*0.55, Math.cos(ang)*240*dm*tier, baseVy + Math.sin(ang)*160*dm*tier, 3.8, 'orb');
          }
        } else if(hpRatio > 0.33){
          const gapW = 200;
          const center = (Math.sin(b.patT*1.0)*0.5+0.5) * (W-gapW) + gapW/2;
          const n = 16;
          for(let i=0;i<n;i++){
            const x = (i/(n-1))*W;
            if(Math.abs(x-center) < gapW/2) continue;
            addBullet(x, b.y + b.h*0.62, 0, 380*dm*tier, 3.9, 'orb');
          }
          const a = aimAtPlayer(660*dm*tier);
          addBullet(b.x, b.y + b.h*0.58, a.vx, a.vy, 3.1, 'needle');
        } else {
          const n = 12;
          const dir = (Math.floor(b.patT*1.3) % 2 === 0) ? 1 : -1;
          for(let i=0;i<n;i++){
            const t = (i/(n-1)-0.5);
            addBullet(b.x, b.y + b.h*0.60, (t*300*dir)*dm, 380*dm*tier, 3.8, 'orb');
          }
          for(let i=0;i<7;i++){
            addBullet(b.x + rand(-b.w*0.33, b.w*0.33), b.y + b.h*0.60, rand(-120,120)*dm*tier, 380*dm*tier, 3.6, 'orb');
          }
        }
        break;
      }
    }
    sfx.enemyShoot();
  }

  // ---------- Rendering ----------
  function drawBackground(dt){
    const scrollSpeed = (120 + 8*state.stage) * KID_SPEED;
    state.bgScroll = (state.bgScroll + scrollSpeed * dt) % H;

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#050713');
    g.addColorStop(0.55, '#070b18');
    g.addColorStop(1, '#04050b');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.26;
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<90;i++){
      const x = (i*97) % W;
      const y = ((i*163) + state.bgScroll) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  function drawGlowCircle(x,y,r,inner,outer,alpha=1){
    ctx.save();
    ctx.globalAlpha = alpha;
    const rg = ctx.createRadialGradient(x,y,0,x,y,r);
    rg.addColorStop(0, inner);
    rg.addColorStop(1, outer);
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawPlayer(){
    const blink = (state.invuln>0 && Math.floor(state.t*14)%2===0);
    ctx.save();
    if(blink) ctx.globalAlpha=0.38;

    ctx.translate(player.x, player.y);

    const bg = ctx.createLinearGradient(0,-30,0,30);
    bg.addColorStop(0, '#f8fbff');
    bg.addColorStop(1, '#b7d6ff');
    ctx.fillStyle = bg;
    ctx.beginPath();
    ctx.moveTo(0, -28);
    ctx.lineTo(20, 26);
    ctx.lineTo(0, 14);
    ctx.lineTo(-20, 26);
    ctx.closePath();
    ctx.fill();

    const wg = ctx.createLinearGradient(-40,0,40,0);
    wg.addColorStop(0, '#1d55ff');
    wg.addColorStop(1, '#59a7ff');
    ctx.fillStyle = wg;
    ctx.beginPath(); ctx.moveTo(-20, 4); ctx.lineTo(-38, 18); ctx.lineTo(-10, 28); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(20, 4); ctx.lineTo(38, 18); ctx.lineTo(10, 28); ctx.closePath(); ctx.fill();

    drawGlowCircle(0,-6,14,'rgba(155,227,255,0.65)','rgba(155,227,255,0)',0.9);
    ctx.fillStyle = '#7db6ff';
    ctx.beginPath(); ctx.ellipse(0, -6, 7, 12, 0, 0, Math.PI*2); ctx.fill();

    if(state.running && !state.paused && !state.gameOver){
      const t = Math.sin(state.t*18)*3;
      drawGlowCircle(0, 34, 18, 'rgba(255,204,102,0.55)', 'rgba(255,204,102,0)', 0.9);
      ctx.fillStyle = '#ffcc66';
      ctx.beginPath();
      ctx.moveTo(0, 28);
      ctx.lineTo(8, 40 + t);
      ctx.lineTo(-8, 40 + t);
      ctx.closePath();
      ctx.fill();
    }

    // ì„œë¸Œì›¨í° ON í‘œì‹œ(ì‘ì€ ìœ„ì„±í¬)
    if(state.subWeapon){
      drawGlowCircle(-34, 8, 16, 'rgba(109,255,178,0.28)', 'rgba(109,255,178,0)', 1);
      drawGlowCircle(34, 8, 16, 'rgba(109,255,178,0.28)', 'rgba(109,255,178,0)', 1);
      ctx.fillStyle = '#6dffb2';
      ctx.beginPath(); ctx.arc(-34, 8, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(34, 8, 4, 0, Math.PI*2); ctx.fill();
    }

    ctx.restore();
  }

  function drawEnemy(e){
    ctx.save();
    ctx.translate(e.x, e.y);

    if(e.carrier){
      e.sparkT += 0.06;
      const pulse = 0.5 + 0.5*Math.sin(e.sparkT*3.2);
      drawGlowCircle(0, -e.h*0.10, 26 + pulse*6, 'rgba(255,215,90,0.55)', 'rgba(255,215,90,0)', 1);
    }

    const g = ctx.createLinearGradient(0, -e.h, 0, e.h);
    g.addColorStop(0, e.carrier ? '#394055' : '#2b3142');
    g.addColorStop(1, e.carrier ? '#141a2b' : '#101421');
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.moveTo(0, -e.h*0.60);
    ctx.lineTo(e.w*0.55, e.h*0.55);
    ctx.lineTo(0, e.h*0.25);
    ctx.lineTo(-e.w*0.55, e.h*0.55);
    ctx.closePath();
    ctx.fill();

    if(e.carrier){
      const pulse = 0.5 + 0.5*Math.sin(e.sparkT*3.2);
      ctx.strokeStyle = `rgba(255,215,90,${0.25 + pulse*0.50})`;
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    ctx.fillStyle = '#ff5a6b';
    ctx.beginPath(); ctx.moveTo(-e.w*0.18, -e.h*0.60); ctx.lineTo(-e.w*0.42, -e.h*0.85); ctx.lineTo(-e.w*0.06, -e.h*0.66); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(e.w*0.18, -e.h*0.60); ctx.lineTo(e.w*0.42, -e.h*0.85); ctx.lineTo(e.w*0.06, -e.h*0.66); ctx.closePath(); ctx.fill();

    drawGlowCircle(-e.w*0.14, -e.h*0.12, 10, 'rgba(255,90,107,0.65)', 'rgba(255,90,107,0)', 0.9);
    drawGlowCircle(e.w*0.14, -e.h*0.12, 10, 'rgba(255,90,107,0.65)', 'rgba(255,90,107,0)', 0.9);
    ctx.fillStyle = '#ff2f4f';
    ctx.beginPath(); ctx.arc(-e.w*0.14, -e.h*0.12, 3.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(e.w*0.14, -e.h*0.12, 3.2, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function drawBoss(){
    const b = state.boss;
    if(!b) return;

    ctx.save();
    ctx.translate(b.x, b.y);

    // í”¼ê²© ë²ˆì©
    if(b.hitFlash > 0){
      drawGlowCircle(0, 0, 76, 'rgba(255,255,255,0.35)', 'rgba(255,255,255,0)', 1);
    }

    const hg = ctx.createLinearGradient(0, -b.h, 0, b.h);
    hg.addColorStop(0, '#2a3246');
    hg.addColorStop(1, '#0f1323');
    ctx.fillStyle = hg;

    ctx.beginPath();
    ctx.moveTo(0, -b.h*0.60);
    ctx.lineTo(b.w*0.48, b.h*0.52);
    ctx.lineTo(0, b.h*0.18);
    ctx.lineTo(-b.w*0.48, b.h*0.52);
    ctx.closePath();
    ctx.fill();

    // ë³´ìŠ¤ì— í•˜ì´ë¼ì´íŠ¸(ê°•í•´ë³´ì´ê²Œ)
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(0, -b.h*0.56);
    ctx.lineTo(b.w*0.30, 0);
    ctx.lineTo(0, b.h*0.12);
    ctx.lineTo(-b.w*0.30, 0);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#ff5a6b';
    ctx.fillRect(-b.w*0.50, -b.h*0.08, b.w*0.16, b.h*0.34);
    ctx.fillRect(b.w*0.34, -b.h*0.08, b.w*0.16, b.h*0.34);

    drawGlowCircle(0, -b.h*0.08, 48, 'rgba(255,204,102,0.20)', 'rgba(255,204,102,0)', 1);
    drawGlowCircle(0, -b.h*0.08, 42, 'rgba(125,182,255,0.35)', 'rgba(125,182,255,0)', 1);
    ctx.fillStyle = '#7db6ff';
    ctx.beginPath(); ctx.ellipse(0, -b.h*0.08, 22, 14, 0, 0, Math.PI*2); ctx.fill();

    ctx.restore();

    // HP bar
    const pad = 18;
    const barW = W - pad*2;
    const barH = 12;
    const ratio = clamp(b.hp / b.hpMax, 0, 1);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    ctx.fillRect(pad, 70, barW, barH);

    ctx.fillStyle = '#ffcc66';
    ctx.fillRect(pad, 70, barW*ratio, barH);

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.strokeRect(pad, 70, barW, barH);
    ctx.globalAlpha = 1;
  }

  function drawBullets(){
    for(const m of pBullets){
      if(m.type==='L'){
        drawGlowCircle(m.x, m.y, 14, 'rgba(217,147,255,0.35)', 'rgba(217,147,255,0)', 1);
        ctx.fillStyle = '#d993ff';
        ctx.fillRect(m.x-1.5, m.y-14, 3, 16);
      } else if(m.type==='S'){
        drawGlowCircle(m.x, m.y, 10, 'rgba(109,255,178,0.25)', 'rgba(109,255,178,0)', 1);
        ctx.fillStyle = '#6dffb2';
        ctx.fillRect(m.x-1.6, m.y-8, 3.2, 10);
      } else {
        drawGlowCircle(m.x, m.y, 12, 'rgba(233,241,255,0.22)', 'rgba(233,241,255,0)', 1);
        ctx.fillStyle = '#e9f1ff';
        ctx.beginPath();
        ctx.roundRect(m.x-2.3, m.y-10, 4.6, 12, 3);
        ctx.fill();
      }
    }

    for(const b of eBullets){
      if(b.spawnDelay && b.spawnDelay > 0) continue;
      if(b.kind==='needle'){
        drawGlowCircle(b.x, b.y, 14, 'rgba(255,204,102,0.26)', 'rgba(255,204,102,0)', 1);
        ctx.fillStyle = '#ffcc66';
        ctx.fillRect(b.x-1.5, b.y-6, 3, 12);
      } else {
        drawGlowCircle(b.x, b.y, 14, 'rgba(255,204,102,0.18)', 'rgba(255,204,102,0)', 1);
        ctx.fillStyle = '#ffcc66';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  function drawPowerups(){
    for(const p of powerups){
      const col = (p.type==='WIDE') ? '#7db6ff' : (p.type==='RAPID' ? '#6dffb2' : '#d993ff');

      ctx.save();
      ctx.translate(p.x, p.y);

      const glow = ctx.createRadialGradient(0,0,3,0,0,18);
      glow.addColorStop(0, col === '#7db6ff' ? 'rgba(125,182,255,0.55)'
                      : col === '#6dffb2' ? 'rgba(109,255,178,0.45)'
                      : 'rgba(217,147,255,0.45)');
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.beginPath(); ctx.roundRect(-13, -13, 26, 26, 7); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.strokeRect(-13, -13, 26, 26);

      ctx.fillStyle = col;
      ctx.fillRect(-2, -13, 4, 26);
      ctx.fillRect(-13, -2, 26, 4);

      ctx.fillStyle = '#0b1020';
      ctx.font = '900 9px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.type==='WIDE'?'W':(p.type==='RAPID'?'R':'L'), 0, 0);

      ctx.restore();
    }
  }

  function drawFx(){
    for(const r of rings){
      ctx.globalAlpha = clamp(r.life*3, 0, 1);
      ctx.strokeStyle = r.col;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.globalAlpha = 0.92;
    for(const p of sparks){
      ctx.fillStyle = p.col;
      ctx.fillRect(p.x, p.y, 3, 3);
    }
    ctx.globalAlpha = 1;
  }

  // ---------- Update ----------
  function update(dt){
    dt *= KID_SPEED;
    state.t += dt;

    if(state.invuln>0) state.invuln = Math.max(0, state.invuln - dt);

    // ì„œë¸Œì›¨í° ìƒíƒœ ê°±ì‹ (í˜¹ì‹œ ìˆ˜ë™ ë³€ê²½ ëŒ€ë¹„)
    state.subWeapon = (powerSum() >= 10);

    // player move
    const follow = 12;
    if(player.targetX!==null){
      player.x += (player.targetX - player.x) * clamp(follow*dt, 0, 1);
      player.y += (player.targetY - player.y) * clamp(follow*dt, 0, 1);
    }
    player.x = clamp(player.x, player.r+10, W-player.r-10);
    player.y = clamp(player.y, player.r+10, H-player.r-10);

    // auto fire (main)
    state._fireTimer += dt;
    const fireEvery = getFireEvery();
    while(state._fireTimer >= fireEvery){
      state._fireTimer -= fireEvery;
      playerFire();
    }

    // auto fire (sub weapon)
    if(state.subWeapon){
      state._subTimer += dt;
      const subEvery = 0.22; // ì„œë¸Œì›¨í° ë°œì‚¬ ê°„ê²©
      while(state._subTimer >= subEvery){
        state._subTimer -= subEvery;
        subWeaponFire();
      }
    } else {
      state._subTimer = 0;
    }

    // spawn enemies
    if(!state.bossActive){
      state.enemySpawnTimer += dt;
      while(state.enemySpawnTimer >= state.enemySpawnEvery){
        state.enemySpawnTimer -= state.enemySpawnEvery;
        spawnEnemy();
      }
    }

    // enemies update
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      e.y += e.vy * dt;

      e.t0 += dt * e.wiggle;
      e.x += Math.sin(e.t0) * 18 * dt * state.diffMul;
      e.x = clamp(e.x, e.w/2+10, W-e.w/2-10);

      e.shootCd -= dt;
      if(e.shootCd <= 0 && !state.bossActive){
        e.shootCd = rand(0.60, 1.30) * state.enemyFireEvery;
        enemyFireFrom(e);
      }

      if(circleHit(player.x, player.y, player.r*0.90, e.x, e.y, Math.max(e.w,e.h)*0.34)){
        onPlayerHit(1);
      }

      if(e.y - e.h > H + 60){
        enemies.splice(i,1);
      }
    }

    // boss update
    if(state.bossActive){
      const b = state.boss;

      if(b.hitFlash > 0) b.hitFlash = Math.max(0, b.hitFlash - dt);

      if(b.y < b.yStop){
        b.y += b.vy * dt;
        if(b.y > b.yStop) b.y = b.yStop;
      } else {
        b.x += b.dir * b.speedX * dt;
        const left = b.w*0.30;
        const right = W - b.w*0.30;
        if(b.x < left){ b.x = left; b.dir = 1; }
        if(b.x > right){ b.x = right; b.dir = -1; }

        b.shootTimer += dt;
        if(b.shootTimer >= b.shootEvery){
          b.shootTimer = 0;
          bossFirePattern();
        }
      }

      if(circleHit(player.x, player.y, player.r*0.90, b.x, b.y, Math.min(b.w,b.h)*0.55)){
        onPlayerHit(1);
      }
    }

    // player bullets
    for(let i=pBullets.length-1;i>=0;i--){
      const m = pBullets[i];
      if(m.curve && m.curve !== 0){
        const ang = Math.atan2(m.vy, m.vx) + m.curve * dt;
        const sp  = Math.max(1, Math.hypot(m.vx, m.vy));
        m.vx = Math.cos(ang) * sp;
        m.vy = Math.sin(ang) * sp;
      }
      m.x += m.vx * dt;
      m.y += m.vy * dt;
      if(m.y < -70 || m.x < -70 || m.x > W+70) pBullets.splice(i,1);
    }

    // enemy bullets (no homing)
    for(let i=eBullets.length-1;i>=0;i--){
      const b = eBullets[i];

      if(b.spawnDelay && b.spawnDelay > 0){
        b.spawnDelay -= dt;
        continue;
      }

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      b.life -= dt;
      if(b.life <= 0){
        eBullets.splice(i,1);
        continue;
      }

      if(circleHit(player.x, player.y, player.r*0.85, b.x, b.y, b.r)){
        eBullets.splice(i,1);
        onPlayerHit(1);
        continue;
      }
      if(b.y > H + 110 || b.x < -130 || b.x > W+130) eBullets.splice(i,1);
    }

    // bullets vs enemies
    for(let ei=enemies.length-1; ei>=0; ei--){
      const e = enemies[ei];
      const er = Math.max(e.w,e.h)*0.34;

      for(let bi=pBullets.length-1; bi>=0; bi--){
        const m = pBullets[bi];
        if(circleHit(m.x, m.y, m.r+2, e.x, e.y, er)){
          e.hp -= m.damage;

          if(m.type==='L' && m.pierce>0) m.pierce -= 1;
          else pBullets.splice(bi,1);

          boom(m.x, m.y, 4, m.type==='L' ? '#d993ff' : '#ffcc66');

          if(e.hp <= 0){
            state.score += (e.kind==='elite' ? 120 : (e.kind==='heavy' ? 70 : 45)) * state.diffMul;
            state.kills += 1;
            boom(e.x, e.y, e.kind==='elite' ? 28 : 18, '#ffcc66');

            if(e.carrier) dropPowerup(e.x, e.y);
            else if(Math.random() < 0.10) dropPowerup(e.x, e.y);

            enemies.splice(ei,1);
          }
          break;
        }
      }
    }

    // bullets vs boss
    if(state.bossActive && state.boss){
      const b = state.boss;
      const br = Math.min(b.w,b.h)*0.55;

      for(let bi=pBullets.length-1; bi>=0; bi--){
        const m = pBullets[bi];
        if(circleHit(m.x, m.y, m.r+2, b.x, b.y, br)){
          b.hp -= m.damage;

          // âœ… ë³´ìŠ¤ í”¼ê²© ì´í™íŠ¸
          bossHitFx(m.x, m.y);

          if(m.type==='L' && m.pierce>0) m.pierce -= 1;
          else pBullets.splice(bi,1);

          if(b.hp <= 0){
            state.score += 1600 * state.diffMul;
            boom(b.x, b.y, 80, '#ffcc66');
            state.bossActive = false;
            state.boss = null;
            enemies.length=0;
            eBullets.length=0;
            powerups.length=0;
            stageClear();
          }
          break;
        }
      }
    }

    // powerups update
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      p.y += p.vy * dt;

      if(circleHit(player.x, player.y, player.r*0.95, p.x, p.y, p.r)){
        powerups.splice(i,1);
        applyPowerup(p.type);
        continue;
      }
      if(p.y > H + 60) powerups.splice(i,1);
    }

    // FX update
    for(let i=sparks.length-1;i>=0;i--){
      const p = sparks[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.90;
      p.vy *= 0.90;
      if(p.life<=0) sparks.splice(i,1);
    }
    for(let i=rings.length-1;i>=0;i--){
      const r = rings[i];
      r.life -= dt;
      r.r += r.vr * dt;
      r.vr *= 0.92;
      if(r.life<=0) rings.splice(i,1);
    }

    // boss trigger
    if(!state.bossActive && state.kills >= state.killsToBoss){
      enemies.length=0;
      eBullets.length=0;
      spawnBoss();
    }

    state.score += dt * (8 * state.diffMul);
    updateHud();
  }

  function loop(ts){
    requestAnimationFrame(loop);
    if(!state.lastTs) state.lastTs = ts;
    const dt = Math.min(0.033, (ts - state.lastTs)/1000);
    state.lastTs = ts;

    // âœ… í™”ë©´ ê¹¨ì§ ë°©ì§€: ë§¤ í”„ë ˆì„ transform ì´ˆê¸°í™”
    ctx.setTransform(DPR,0,0,DPR,0,0);

    drawBackground(dt);

    if(state.running && !state.paused && !state.gameOver){
      update(dt);
    }

    drawPowerups();
    for(const e of enemies) drawEnemy(e);
    if(state.bossActive) drawBoss();
    drawBullets();
    drawFx();
    drawPlayer();

    if(state.paused && !state.gameOver){
      ctx.fillStyle='rgba(0,0,0,0.40)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff';
      ctx.font='900 28px system-ui';
      ctx.textAlign='center';
      ctx.fillText('ì¼ì‹œì •ì§€', W/2, H/2);
      ctx.font='700 14px system-ui';
      ctx.fillText('ì˜¤ë¥¸ìª½ ìœ„ "ì¬ê°œ"ë¥¼ ëˆ„ë¥´ì„¸ìš”', W/2, H/2 + 28);
    }
  }

  // init
  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
