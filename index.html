<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#070a14" />
  <title>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ…</title>
  <link rel="manifest" href="manifest.json" />
  <style>
    html, body { margin:0; height:100%; background:#070a14; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; }
    #wrap { position: relative; width:100%; height:100%; }
    canvas { width:100%; height:100%; display:block; touch-action:none; }

    .hud{
      position:absolute; left:12px; top:12px;
      color:#fff; font-weight:900; font-size:13.5px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.75);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      max-width: calc(100% - 170px);
      pointer-events:none;
    }
    .hud span{
      opacity:0.95; padding:6px 10px; border-radius:14px;
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.08);
    }
    .btns{ position:absolute; right:12px; top:12px; display:flex; gap:8px; }
    button{
      appearance:none; border:0; border-radius:14px; padding:10px 12px;
      font-weight:900; background:rgba(255,255,255,0.12); color:#fff; backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.08);
    }
    button:active{ transform: translateY(1px); }

    .panel{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      color:#fff; text-align:center;
      padding:14px 16px; border-radius:18px;
      background:rgba(0,0,0,0.52);
      width:min(680px, 94vw);
      line-height:1.45;
      box-shadow: 0 14px 40px rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .panel b{ font-size:18px; display:block; margin-bottom:10px; }
    .panel small{ opacity:0.92; display:block; margin-top:10px; }

    .row{
      display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap;
      margin-top:10px;
    }
    input{
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color:#fff;
      border-radius: 12px;
      padding:10px 12px;
      font-weight: 900;
      outline:none;
      width:min(220px, 70vw);
      text-align:center;
    }

    .board{
      margin-top: 10px;
      text-align:left;
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding:10px 12px;
      max-height: 240px;
      overflow:auto;
    }
    .board .h{
      display:flex; justify-content:space-between; font-weight:900; opacity:0.95;
      margin-bottom:6px;
    }
    .board .item{
      display:flex; justify-content:space-between; padding:6px 0;
      border-top:1px solid rgba(255,255,255,0.08);
      font-weight:800;
    }
    .muted{ opacity:0.85; font-weight:800; }

    .toast{
      position:absolute; left:50%; bottom:18px;
      transform:translateX(-50%);
      color:#fff; font-weight:900;
      background: rgba(0,0,0,0.55);
      padding:10px 12px; border-radius:14px;
      opacity:0; pointer-events:none;
      transition: opacity 160ms ease;
      border:1px solid rgba(255,255,255,0.08);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    }
    .toast.show{ opacity:1; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <span id="stage">ìŠ¤í…Œì´ì§€: 1/20</span>
    <span id="score">ì ìˆ˜: 0</span>
    <span id="life">ëª©ìˆ¨: 10</span>
    <span id="pow">íŒŒì›Œì—…: W0 R0 L0</span>
    <span id="sub">ì„œë¸Œì›¨í°: OFF</span>
  </div>

  <div class="btns">
    <button id="soundBtn">ì‚¬ìš´ë“œ ON</button>
    <button id="pauseBtn">ì¼ì‹œì •ì§€</button>
    <button id="restartBtn">ì¬ì‹œì‘</button>
  </div>

  <div id="panel" class="panel">
    <b>ë¯¼ìš° 1945 ìŠ¤í…Œì´ì§€ ìŠˆíŒ… âœˆï¸</b>
    <div class="muted">ë“œë˜ê·¸ ì´ë™ / ìë™ë°œì‚¬ / 20ìŠ¤í…Œì´ì§€ / ë³´ìŠ¤ í”¼ê²© ì´í™íŠ¸</div>

    <div class="row">
      <div style="font-weight:900;">ì´ë¦„(ë­í‚¹ ì €ì¥):</div>
      <input id="nameInput" maxlength="10" placeholder="ë¯¼ìš°" />
      <button id="saveNameBtn">ì´ë¦„ ì €ì¥</button>
    </div>

    <div class="board" id="board">
      <div class="h"><span>ë­í‚¹ TOP 10</span><span>ì ìˆ˜</span></div>
      <div class="muted">ì•„ì§ ê¸°ë¡ì´ ì—†ì–´ìš”. ğŸ˜„</div>
    </div>

    <small>(í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ í„°ì¹˜í•˜ë©´ ì‹œì‘)</small>
  </div>

  <div id="toast" class="toast">POWER UP!</div>
</div>

<script>
(() => {
  // ============================
  // âœ… íŠœë‹ í¬ì¸íŠ¸
  // ============================
  const KID_SPEED = 0.78;          // ì•„ì´ìš© ê¸°ë³¸ ì†ë„ (ëŠë¦¬ê²Œ 0.72 / ë¹ ë¥´ê²Œ 0.82)
  const STAGE_GROWTH = 1.075;      // ìŠ¤í…Œì´ì§€ ê¸°ë³¸ ë‚œì´ë„ ì¦ê°€
  const MAX_STAGE = 20;

  // "íŒŒì›Œì—… ë¨¹ì„ìˆ˜ë¡ ì ë„ ê°•í•´ì§€ëŠ”" ìë™ë°¸ëŸ°ì‹± ê°•ë„
  // (ê°’ì„ ì˜¬ë¦¬ë©´: íŒŒì›Œì—… ë¨¹ì–´ë„ ë„ˆë¬´ ì‰¬ì›Œì§€ì§€ ì•ŠìŒ)
  const POWER_ENEMY_SCALE = 0.032; // 0.025~0.045 ì¶”ì²œ

  // ë­í‚¹ ì €ì¥
  const LS_NAME = 'minwoo_player_name_v1';
  const LS_RANK = 'minwoo_leaderboard_v1';

  // PWA
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
  }

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  const elStage = document.getElementById('stage');
  const elScore = document.getElementById('score');
  const elLife  = document.getElementById('life');
  const elPow   = document.getElementById('pow');
  const elSub   = document.getElementById('sub');

  const panel = document.getElementById('panel');
  const toast = document.getElementById('toast');

  const soundBtn = document.getElementById('soundBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  const nameInput = document.getElementById('nameInput');
  const saveNameBtn = document.getElementById('saveNameBtn');
  const boardEl = document.getElementById('board');

  let W=0, H=0, DPR=1;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- ë­í‚¹ ----------
  function getPlayerName(){
    const saved = (localStorage.getItem(LS_NAME) || '').trim();
    return saved || 'ë¯¼ìš°';
  }
  function setPlayerName(n){
    const name = (n || '').trim().slice(0,10) || 'ë¯¼ìš°';
    localStorage.setItem(LS_NAME, name);
    nameInput.value = name;
  }
  function readBoard(){
    try{
      const raw = localStorage.getItem(LS_RANK);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(e){ return []; }
  }
  function writeBoard(arr){
    localStorage.setItem(LS_RANK, JSON.stringify(arr));
  }
  function renderBoard(){
    const arr = readBoard();
    if(arr.length === 0){
      boardEl.innerHTML = `
        <div class="h"><span>ë­í‚¹ TOP 10</span><span>ì ìˆ˜</span></div>
        <div class="muted">ì•„ì§ ê¸°ë¡ì´ ì—†ì–´ìš”. ğŸ˜„</div>
      `;
      return;
    }
    const rows = arr.slice(0,10).map((r,idx)=>{
      const stage = r.stage ? ` (S${r.stage})` : '';
      const dt = r.date ? ` Â· ${r.date}` : '';
      return `<div class="item"><span>${idx+1}. ${escapeHtml(r.name || 'ë¯¼ìš°')}${stage}<span class="muted">${dt}</span></span><span>${Math.floor(r.score||0)}</span></div>`;
    }).join('');
    boardEl.innerHTML = `<div class="h"><span>ë­í‚¹ TOP 10</span><span>ì ìˆ˜</span></div>${rows}`;
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  function saveScoreToBoard(score, stage){
    const name = getPlayerName();
    const now = new Date();
    const date = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
    const arr = readBoard();
    arr.push({name, score: Math.floor(score), stage, date});
    arr.sort((a,b)=> (b.score||0) - (a.score||0));
    writeBoard(arr.slice(0,10));
    renderBoard();
  }

  setPlayerName(getPlayerName());
  renderBoard();

  saveNameBtn.addEventListener('click', ()=>{
    setPlayerName(nameInput.value);
    showToast(`ì´ë¦„ ì €ì¥: ${getPlayerName()}`);
  });

  // ---------- Sound ----------
  let audioEnabled = true;
  soundBtn.textContent = 'ì‚¬ìš´ë“œ ON';

  function beep(freq=440, dur=0.06, type='sine', gain=0.06) {
    if (!audioEnabled) return;
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) return;
    const ac = beep._ac || (beep._ac = new AudioCtx());
    if (ac.state === 'suspended') ac.resume().catch(()=>{});
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = gain;
    o.connect(g); g.connect(ac.destination);
    const t = ac.currentTime;
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.start(t); o.stop(t + dur);
  }
  const sfx = {
    start(){ beep(660,0.06,'triangle',0.06); beep(880,0.06,'triangle',0.05); },
    shoot(){ beep(780,0.03,'square',0.040); },
    sub(){ beep(920,0.03,'square',0.028); },
    laser(){ beep(980,0.04,'sawtooth',0.040); },
    hit(){ beep(140,0.10,'sawtooth',0.075); },
    boom(){ beep(220,0.06,'square',0.06); beep(110,0.10,'sawtooth',0.05); },
    power(){ beep(980,0.06,'triangle',0.08); beep(1320,0.06,'triangle',0.06); },
    enemyShoot(){ beep(420,0.04,'sine',0.028); },
    boss(){ beep(240,0.12,'square',0.07); beep(180,0.14,'square',0.05); },
    bossHit(){ beep(520,0.03,'sine',0.035); },
    clear(){ beep(880,0.08,'triangle',0.07); beep(1320,0.10,'triangle',0.06); beep(1760,0.12,'triangle',0.05); }
  };

  soundBtn.addEventListener('click', () => {
    audioEnabled = !audioEnabled;
    soundBtn.textContent = audioEnabled ? 'ì‚¬ìš´ë“œ ON' : 'ì‚¬ìš´ë“œ OFF';
    beep(440,0.04,'sine',0.04);
  });

  function showToast(text){
    toast.textContent = text;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 560);
  }

  // ---------- Game State ----------
  const state = {
    running:false, paused:false, gameOver:false, cleared:false,
    t:0, lastTs:0,

    stage:1,
    score:0,

    lives:10,
    invuln:0,

    wideLv:0, rapidLv:0, laserLv:0,
    subWeapon:false,

    bgScroll:0,

    kills:0,
    killsToBoss: 28,
    bossActive:false,

    // difficulty dynamic
    stageMul:1.0,   // stage baseline
    powerMul:1.0,   // based on powerSum

    enemySpawnTimer:0,
    enemySpawnEvery:0.72,
    enemySpeed: 185,
    enemyFireEvery:1.25,

    boss:null,
    _fireTimer:0,
    _subTimer:0,
  };

  function powerSum(){ return state.wideLv + state.rapidLv + state.laserLv; }

  function recomputeDifficulty(){
    // ìŠ¤í…Œì´ì§€ê°€ ì˜¤ë¥¼ìˆ˜ë¡ ê¸°ë³¸ ì¦ê°€
    state.stageMul = Math.pow(STAGE_GROWTH, state.stage - 1);

    // íŒŒì›Œì—…ì´ ì˜¤ë¥¼ìˆ˜ë¡ ì ë„ ê°™ì´ ì¦ê°€(ê°€ë§Œíˆ ìˆì–´ë„ ëë‚˜ëŠ” í˜„ìƒ ë°©ì§€)
    const p = powerSum();
    state.powerMul = 1.0 + p * POWER_ENEMY_SCALE;   // p=20ì´ë©´ ì•½ +64%

    // í•©ì³ì§„ ë‚œì´ë„
    const d = state.stageMul * state.powerMul;

    // ìŠ¤í°/ë°œì‚¬/ì†ë„: ë„ˆë¬´ ê³¼í•´ì§€ì§€ ì•Šê²Œ clamp
    state.enemySpeed = 185 * d;

    // ìŠ¤í° ê°„ê²©(ì‘ì„ìˆ˜ë¡ ë§ì´ ë‚˜ì˜´)
    state.enemySpawnEvery = clamp(0.78 / d, 0.28, 0.92);

    // ì  ë°œì‚¬ ê°„ê²©(ì‘ì„ìˆ˜ë¡ ìì£¼ ì¨)
    state.enemyFireEvery  = clamp(1.35 / d, 0.45, 1.55);

    // ë³´ìŠ¤ ë“±ì¥ê¹Œì§€ ì²˜ì¹˜ìˆ˜(ë„ˆë¬´ ë¹¨ë¦¬ ë³´ìŠ¤ ê°€ëŠ” ê±¸ ë°©ì§€)
    state.killsToBoss = Math.floor(24 + state.stage * 4 + Math.min(16, p*0.8));
  }

  function updateHud(){
    elStage.textContent = `ìŠ¤í…Œì´ì§€: ${state.stage}/${MAX_STAGE}`;
    elScore.textContent = `ì ìˆ˜: ${Math.floor(state.score)}`;
    elLife.textContent  = `ëª©ìˆ¨: ${state.lives}`;
    elPow.textContent   = `íŒŒì›Œì—…: W${state.wideLv} R${state.rapidLv} L${state.laserLv}`;
    elSub.textContent   = `ì„œë¸Œì›¨í°: ${state.subWeapon ? 'ON' : 'OFF'}`;
  }
  updateHud();

  // ---------- Objects ----------
  const player = { x: W*0.5, y: H*0.82, r:18, targetX:null, targetY:null };
  const enemies = [];  // {x,y,w,h,vy,hp,shootCd,kind,wiggle,t0,carrier,sparkT}
  const pBullets = []; // {x,y,vx,vy,r,damage,type,pierce,curve,from}
  const eBullets = []; // {x,y,vx,vy,r,damage,kind,spawnDelay,life}
  const powerups = []; // {x,y,vy,r,type}
  const sparks = [];   // fx
  const rings  = [];

  // ---------- Controls ----------
  let isPointerDown=false;
  function pointerPos(e){
    const rect = canvas.getBoundingClientRect();
    return { x: (e.clientX-rect.left), y:(e.clientY-rect.top) };
  }
  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    isPointerDown=true;
    const p = pointerPos(e);

    if(!state.running && !state.gameOver && !state.cleared){
      state.running=true; panel.style.display='none'; sfx.start();
    } else if(state.gameOver || state.cleared){
      resetGame();
      state.running=true; panel.style.display='none'; sfx.start();
    }

    player.targetX=p.x; player.targetY=p.y;
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!isPointerDown) return;
    const p = pointerPos(e);
    player.targetX=p.x; player.targetY=p.y;
  });
  canvas.addEventListener('pointerup', ()=>{
    isPointerDown=false;
    player.targetX=null; player.targetY=null;
  });

  pauseBtn.addEventListener('click', ()=>{
    if(!state.running && !state.gameOver) return;
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? 'ì¬ê°œ' : 'ì¼ì‹œì •ì§€';
    beep(300,0.04,'sine',0.04);
  });

  restartBtn.addEventListener('click', ()=>{
    resetGame();
    state.running=true;
    panel.style.display='none';
    sfx.start();
  });

  // ---------- Helpers ----------
  function circleHit(ax,ay,ar,bx,by,br){
    const dx=ax-bx, dy=ay-by;
    const rr=ar+br;
    return (dx*dx+dy*dy) <= rr*rr;
  }
  function boom(x,y,amount=18, col='#ffcc66'){
    for(let i=0;i<amount;i++){
      const a = rand(0, Math.PI*2);
      const sp = rand(70, 340);
      sparks.push({x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.18,0.55), col});
    }
    rings.push({x,y, r: 6, vr: rand(220, 420), life: rand(0.18, 0.32), col});
    sfx.boom();
    if(navigator.vibrate) navigator.vibrate(10);
  }
  function bossHitFx(x,y){
    rings.push({x,y, r: 10, vr: 520, life: 0.20, col: '#ffffff'});
    rings.push({x,y, r: 6, vr: 420, life: 0.18, col: '#7db6ff'});
    sfx.bossHit();
    if(state.boss) state.boss.hitFlash = 0.12;
  }
  function onPlayerHit(dmg=1){
    if(state.invuln>0) return;
    state.lives -= dmg;
    state.invuln = 1.10;
    sfx.hit();
    if(navigator.vibrate) navigator.vibrate(60);
    updateHud();

    if(state.lives<=0){
      gameOver();
    } else {
      showToast(`-1 ëª©ìˆ¨! (ë‚¨ì€ ${state.lives})`);
    }
  }

  function dropPowerup(x,y){
    const r = Math.random();
    let type = 'WIDE';
    if(r < 0.34) type = 'WIDE';
    else if(r < 0.68) type = 'RAPID';
    else type = 'LASER';
    powerups.push({x,y, vy: 115 * state.stageMul, r: 12, type});
  }

  function applyPowerup(type){
    if(type==='WIDE')  state.wideLv += 1;
    if(type==='RAPID') state.rapidLv += 1;
    if(type==='LASER') state.laserLv += 1;

    sfx.power();
    showToast(`POWER UP! (í•©:${powerSum()})`);

    state.subWeapon = (powerSum() >= 10);
    recomputeDifficulty(); // âœ… íŒŒì›Œì—… ë¨¹ìœ¼ë©´ ì ë„ ê°™ì´ ê°•í•´ì§
    updateHud();
  }

  // ---------- Stage / Flow ----------
  function setStage(n){
    state.stage = n;
    state.kills = 0;
    state.bossActive = false;
    state.boss = null;

    recomputeDifficulty();

    enemies.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;
    updateHud();
  }

  function resetGame(){
    state.running=false; state.paused=false; state.gameOver=false; state.cleared=false;
    state.t=0; state.bgScroll=0;
    state.score=0;
    state.lives=10;
    state.invuln=0;

    state.wideLv=0; state.rapidLv=0; state.laserLv=0;
    state.subWeapon=false;

    enemies.length=0; pBullets.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;

    player.x=W*0.5; player.y=H*0.82;
    player.targetX=null; player.targetY=null;

    state.enemySpawnTimer=0;
    state._fireTimer=0;
    state._subTimer=0;

    setStage(1);

    panel.style.display='block';
    renderBoard();
    pauseBtn.textContent='ì¼ì‹œì •ì§€';
    updateHud();
  }

  function gameOver(){
    state.gameOver=true;
    state.running=false;
    state.paused=false;

    // âœ… ë­í‚¹ ì €ì¥
    saveScoreToBoard(state.score, state.stage);

    panel.style.display='block';
    renderBoard();
    panel.querySelector('b').textContent = 'ê²Œì„ ì˜¤ë²„ ğŸ˜µ';
    // ë³´ë“œ ìœ„ì— ì•ˆë‚´ ì¶”ê°€
    const info = document.createElement('div');
    info.style.marginTop = '8px';
    info.style.fontWeight = '900';
    info.innerHTML = `ì ìˆ˜: <b>${Math.floor(state.score)}</b> Â· ìŠ¤í…Œì´ì§€: <b>${state.stage}</b><div style="margin-top:8px;">í„°ì¹˜í•˜ë©´ ë‹¤ì‹œ ì‹œì‘</div>`;
    panel.insertBefore(info, boardEl);
  }

  function stageClear(){
    state.running=false;
    state.paused=false;

    if(state.stage >= MAX_STAGE){
      state.cleared=true;
      // âœ… ë­í‚¹ ì €ì¥
      saveScoreToBoard(state.score, state.stage);

      sfx.clear();
      panel.style.display='block';
      renderBoard();
      panel.querySelector('b').textContent = 'ì „ì²´ í´ë¦¬ì–´! ğŸ‰';
      const info = document.createElement('div');
      info.style.marginTop = '8px';
      info.style.fontWeight = '900';
      info.innerHTML = `20 ìŠ¤í…Œì´ì§€ ì™„ì£¼! ì ìˆ˜: <b>${Math.floor(state.score)}</b><div style="margin-top:8px;">í„°ì¹˜í•˜ë©´ ë‹¤ì‹œ(1ìŠ¤í…Œì´ì§€)</div>`;
      panel.insertBefore(info, boardEl);
      return;
    }

    const next = state.stage + 1;
    sfx.clear();
    panel.style.display='block';
    renderBoard();
    panel.querySelector('b').textContent = `ìŠ¤í…Œì´ì§€ ${state.stage} í´ë¦¬ì–´! âœ…`;

    const info = document.createElement('div');
    info.style.marginTop = '8px';
    info.style.fontWeight = '900';
    info.innerHTML = `ë‹¤ìŒ ìŠ¤í…Œì´ì§€: <b>${next}</b><div class="muted" style="margin-top:6px;">ìŠ¤í…Œì´ì§€ê°€ ì˜¤ë¥¼ìˆ˜ë¡ ì /ë³´ìŠ¤ê°€ ë” ê°•í•´ì§‘ë‹ˆë‹¤.</div><div style="margin-top:8px;">í„°ì¹˜í•˜ë©´ ì‹œì‘</div>`;
    panel.insertBefore(info, boardEl);

    setStage(next);
    enemies.length=0; pBullets.length=0; eBullets.length=0; powerups.length=0; sparks.length=0; rings.length=0;
  }

  // ---------- Spawning ----------
  function spawnEnemy(){
    const d = state.stageMul * state.powerMul;

    const size = rand(0,1);
    const w = size < 0.6 ? rand(28, 42) : rand(44, 58);
    const h = size < 0.6 ? rand(24, 34) : rand(34, 44);
    const x = rand(w/2 + 12, W - w/2 - 12);
    const y = -h - 10;

    const vy = (185 * d) * rand(0.80, 1.08);

    // âœ… ìŠ¤í…Œì´ì§€+íŒŒì›Œì— ë”°ë¼ HP ì¦ê°€
    // íŒŒì›Œê°€ ë†’ì•„ë„ "ê°€ë§Œíˆ ìˆìœ¼ë©´ ë" ë°©ì§€: HPê°€ ê°™ì´ ì˜¬ë¼ê°
    const baseHp =
      (w > 46) ? 5 :
      (Math.random() < 0.18 ? 3 : 2);

    const hpBoost = Math.floor((state.stage-1)/2) + Math.floor(powerSum()/6); // ìŠ¤í…Œì´ì§€/íŒŒì›Œ êµ¬ê°„ë³„ ì¦ê°€
    const hp = baseHp + hpBoost;

    const kind = (hp >= 8) ? 'elite' : (hp >= 5 ? 'heavy' : 'normal');

    const carrierChance = clamp(0.22 - powerSum()*0.002, 0.12, 0.22);
    const carrier = Math.random() < carrierChance;

    enemies.push({
      x,y,w,h,vy,hp,
      shootCd: rand(0.55, 1.20),
      kind,
      wiggle: rand(0.5, 1.0),
      t0: rand(0, 10),
      carrier,
      sparkT: rand(0, 10)
    });
  }

  function spawnBoss(){
    const d = state.stageMul * state.powerMul;

    const w = Math.min(290, W * 0.72);
    const h = 128;
    const x = W * 0.5;
    const y = -h - 40;

    // âœ… ìŠ¤í…Œì´ì§€+íŒŒì›Œì— ë”°ë¼ ë³´ìŠ¤ HP ì¦ê°€(í™•ì‹¤íˆ ì²´ê°)
    const hpMax = Math.floor((420 + state.stage*85) * d * 1.18);

    state.boss = {
      x,y,w,h,
      yStop: 118,
      vy: 120 * d,
      dir: 1,
      speedX: (90 + 12*state.stage) * (0.92 + Math.min(0.18, powerSum()*0.01)),
      hp: hpMax,
      hpMax,
      shootTimer: 0,
      // âœ… ìŠ¤í…Œì´ì§€ê°€ ì˜¤ë¥¼ìˆ˜ë¡ ë” ìì£¼ ì¨
      shootEvery: clamp(0.95 / d, 0.22, 0.95),
      patT: 0,
      hitFlash: 0,
      tier: (state.stage > 10 ? 1.15 : 1.00)
    };
    state.bossActive = true;
    sfx.boss();
    showToast(`ğŸ‘‘ ë³´ìŠ¤ ë“±ì¥! (Stage ${state.stage})`);
    if(navigator.vibrate) navigator.vibrate([30,30,30]);
  }

  // ---------- Shooting ----------
  function getFireEvery(){
    // í”Œë ˆì´ì–´ ì—°ì‚¬: ë„ˆë¬´ ë¹¨ë¼ì§€ëŠ” ê±´ ì œí•œ
    return clamp(0.18 - state.rapidLv*0.010, 0.08, 0.18);
  }

  function playerFire(){
    const baseVy = 900;
    const count = 1 + Math.min(10, state.wideLv);
    const spreadBase = 70 + Math.min(12, state.wideLv) * 24;

    const p = powerSum();
    const curvePow = Math.max(0, p - 8);
    const curveBase = Math.min(2.2, curvePow * 0.10);

    if(count === 1){
      pBullets.push({x: player.x, y: player.y - player.r - 8, vx: 0, vy: -baseVy, r: 3.1, damage: 1, type:'N', pierce:0, curve: (Math.random()<0.5?-1:1)*curveBase, from:'main'});
    } else {
      for(let i=0;i<count;i++){
        const t = (i/(count-1) - 0.5);
        const vx = t * spreadBase * 2.2;
        pBullets.push({
          x: player.x + t*18,
          y: player.y - player.r - 8,
          vx, vy: -baseVy,
          r: 3.0, damage: 1,
          type:'N', pierce:0,
          curve: (t===0? (Math.random()<0.5?-1:1) : Math.sign(t)) * curveBase * 0.85,
          from:'main'
        });
      }
    }

    if(state.laserLv > 0){
      const pierce = Math.min(22, state.laserLv);
      const dmg = 2 + Math.floor(state.laserLv/2) + Math.min(12, state.laserLv);
      pBullets.push({x: player.x, y: player.y - player.r - 10, vx: 0, vy: -1200, r: 2.6, damage: dmg, type:'L', pierce, curve: 0, from:'main'});
      sfx.laser();
    } else {
      sfx.shoot();
    }
  }

  function subWeaponFire(){
    const y = player.y - player.r - 6;
    const leftX  = player.x - 34;
    const rightX = player.x + 34;

    const lvl = Math.floor((powerSum() - 10) / 5);
    const dmg = 1 + Math.min(4, lvl);
    const spd = -980;

    pBullets.push({x:leftX,  y, vx: -40, vy: spd, r: 2.7, damage: dmg, type:'S', pierce:0, curve: 0, from:'sub'});
    pBullets.push({x:rightX, y, vx:  40, vy: spd, r: 2.7, damage: dmg, type:'S', pierce:0, curve: 0, from:'sub'});
    sfx.sub();
  }

  // ì  íƒ„: í•œë²ˆ ì¡°ì¤€ í›„ ì§ì„  (3ë°œ ê°„ê²©)
  function enemyFireFrom(e){
    const d = state.stageMul * state.powerMul;

    const speed = 290 * d;
    const baseDelay = 0.16; // ì•½ê°„ ë” ì²œì²œíˆ
    const shots = 3;

    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const len = Math.max(1, Math.hypot(dx,dy));
    const ax = (dx/len) * speed;
    const ay = (dy/len) * speed;

    const vx0 = clamp(ax, -240*d, 240*d);
    const vy0 = Math.max(200*d, ay);

    for(let i=0;i<shots;i++){
      eBullets.push({
        x: e.x, y: e.y + e.h*0.55,
        vx: vx0, vy: vy0,
        r: 4.0, damage: 1,
        kind: 'aim',
        spawnDelay: i * baseDelay,
        life: 6.0
      });
    }
    sfx.enemyShoot();
  }

  // ë³´ìŠ¤ íŒ¨í„´: ìŠ¤í…Œì´ì§€ ì˜¬ë¼ê°ˆìˆ˜ë¡ ê°•ë„ ìƒìŠ¹
  function bossFirePattern(){
    const b = state.boss;
    if(!b) return;

    const d = state.stageMul * state.powerMul;
    const cycle = ((state.stage - 1) % 10) + 1;
    const tier = (state.stage > 10) ? 1.18 : 1.00;

    // ìŠ¤í…Œì´ì§€ê°€ ì˜¤ë¥¼ìˆ˜ë¡ íƒ„ë§‰ì´ ì¡°ê¸ˆì”© ë‘êº¼ì›Œì§
    const dense = 1 + Math.floor((state.stage-1)/4); // 1~5

    const baseVy = 330 * d * tier;
    const sx = 250 * tier;

    const addBullet = (x,y,vx,vy,r=4.0, kind='orb') =>
      eBullets.push({x,y,vx,vy,r,damage:1,kind, spawnDelay:0, life:8.0});

    const aimAtPlayer = (speed=500*d*tier) => {
      const dx = player.x - b.x;
      const dy = (player.y - b.y);
      const len = Math.max(1, Math.hypot(dx,dy));
      return { vx: (dx/len)*speed, vy: (dy/len)*speed };
    };

    b.patT += b.shootEvery;

    switch(cycle){
      case 1: {
        const n = 8 + dense;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*36, b.y + b.h*0.60, t*sx*d*0.9, baseVy, 4.0, 'orb');
        }
        break;
      }
      case 2: {
        const kmax = 4 + Math.min(3, dense);
        for(let k=0;k<kmax;k++){
          const a = aimAtPlayer((520 + k*22)*d*tier);
          addBullet(b.x, b.y + b.h*0.60, a.vx, a.vy, 4.2, 'orb');
        }
        break;
      }
      case 3: {
        const n = 10 + dense;
        const ang0 = b.patT * 1.15;
        for(let i=0;i<n;i++){
          const ang = ang0 + i*(Math.PI*2/n);
          addBullet(b.x, b.y + b.h*0.55, Math.cos(ang)*210*d*tier, baseVy + Math.sin(ang)*140*d*tier, 3.8, 'orb');
        }
        break;
      }
      case 4: {
        const n = 9 + dense;
        const wv = Math.sin(b.patT*1.0) * 1.0;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*58, b.y + b.h*0.58, (t*250 + wv*230)*d*tier, baseVy, 4.0, 'orb');
        }
        break;
      }
      case 5: {
        const n = 10 + dense*2;
        for(let i=0;i<n;i++){
          addBullet(b.x + rand(-b.w*0.33, b.w*0.33), b.y + b.h*0.62, rand(-90,90)*d*tier, baseVy + rand(0,150)*d*tier, 3.7, 'orb');
        }
        break;
      }
      case 6: {
        for(let t of [-1, 1]){
          addBullet(b.x + t*46, b.y + b.h*0.60, t*230*d*tier, baseVy, 4.0, 'orb');
          addBullet(b.x + t*12, b.y + b.h*0.60, t*150*d*tier, baseVy+95*d*tier, 4.0, 'orb');
        }
        const a = aimAtPlayer(560*d*tier);
        addBullet(b.x, b.y + b.h*0.60, a.vx, a.vy, 4.4, 'orb');
        break;
      }
      case 7: {
        const n = 11 + dense;
        const dir = (Math.floor(b.patT*1.2) % 2 === 0) ? 1 : -1;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x, b.y + b.h*0.60, (t*sx*dir)*d, baseVy, 3.9, 'orb');
        }
        break;
      }
      case 8: {
        const gapW = 180;
        const center = (Math.sin(b.patT*0.85)*0.5+0.5) * (W-gapW) + gapW/2;
        const n = 14 + dense*2;
        for(let i=0;i<n;i++){
          const x = (i/(n-1))*W;
          if(Math.abs(x-center) < gapW/2) continue;
          addBullet(x, b.y + b.h*0.62, 0, 380*d*tier, 3.9, 'orb');
        }
        break;
      }
      case 9: {
        const n = 12 + dense*2;
        for(let i=0;i<n;i++){
          const t = (i/(n-1)-0.5);
          addBullet(b.x + t*86, b.y + b.h*0.60, t*200*d*tier, baseVy+95*d*tier, 3.7, 'orb');
        }
        const a = aimAtPlayer(700*d*tier);
        addBullet(b.x, b.y + b.h*0.58, a.vx, a.vy, 3.2, 'needle');
        break;
      }
      case 10: {
        const hpRatio = b.hp / b.hpMax;
        if(hpRatio > 0.66){
          const n = 10 + dense;
          const ang0 = b.patT * 1.25;
          for(let i=0;i<n;i++){
            const ang = ang0 + i*(Math.PI*2/n);
            addBullet(b.x, b.y + b.h*0.55, Math.cos(ang)*250*d*tier, baseVy + Math.sin(ang)*170*d*tier, 3.8, 'orb');
          }
        } else if(hpRatio > 0.33){
          const gapW = 200;
          const center = (Math.sin(b.patT*1.0)*0.5+0.5) * (W-gapW) + gapW/2;
          const n = 16 + dense;
          for(let i=0;i<n;i++){
            const x = (i/(n-1))*W;
            if(Math.abs(x-center) < gapW/2) continue;
            addBullet(x, b.y + b.h*0.62, 0, 410*d*tier, 3.9, 'orb');
          }
          const a = aimAtPlayer(760*d*tier);
          addBullet(b.x, b.y + b.h*0.58, a.vx, a.vy, 3.1, 'needle');
        } else {
          const n = 12 + dense*2;
          const dir = (Math.floor(b.patT*1.3) % 2 === 0) ? 1 : -1;
          for(let i=0;i<n;i++){
            const t = (i/(n-1)-0.5);
            addBullet(b.x, b.y + b.h*0.60, (t*320*dir)*d, 410*d*tier, 3.8, 'orb');
          }
          for(let i=0;i<8 + dense;i++){
            addBullet(b.x + rand(-b.w*0.33, b.w*0.33), b.y + b.h*0.60, rand(-140,140)*d*tier, 410*d*tier, 3.6, 'orb');
          }
        }
        break;
      }
    }
    sfx.enemyShoot();
  }

  // ---------- Rendering ----------
  function drawBackground(dt){
    const scrollSpeed = (120 + 8*state.stage) * KID_SPEED;
    state.bgScroll = (state.bgScroll + scrollSpeed * dt) % H;

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#050713');
    g.addColorStop(0.55, '#070b18');
    g.addColorStop(1, '#04050b');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.26;
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<90;i++){
      const x = (i*97) % W;
      const y = ((i*163) + state.bgScroll) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }
  function drawGlowCircle(x,y,r,inner,outer,alpha=1){
    ctx.save();
    ctx.globalAlpha = alpha;
    const rg = ctx.createRadialGradient(x,y,0,x,y,r);
    rg.addColorStop(0, inner);
    rg.addColorStop(1, outer);
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawPlayer(){
    const blink = (state.invuln>0 && Math.floor(state.t*14)%2===0);
    ctx.save();
    if(blink) ctx.globalAlpha=0.38;

    ctx.translate(player.x, player.y);

    const bg = ctx.createLinearGradient(0,-30,0,30);
    bg.addColorStop(0, '#f8fbff');
    bg.addColorStop(1, '#b7d6ff');
    ctx.fillStyle = bg;
    ctx.beginPath();
    ctx.moveTo(0, -28);
    ctx.lineTo(20, 26);
    ctx.lineTo(0, 14);
    ctx.lineTo(-20, 26);
    ctx.closePath();
    ctx.fill();

    const wg = ctx.createLinearGradient(-40,0,40,0);
    wg.addColorStop(0, '#1d55ff');
    wg.addColorStop(1, '#59a7ff');
    ctx.fillStyle = wg;
    ctx.beginPath(); ctx.moveTo(-20, 4); ctx.lineTo(-38, 18); ctx.lineTo(-10, 28); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(20, 4); ctx.lineTo(38, 18); ctx.lineTo(10, 28); ctx.closePath(); ctx.fill();

    drawGlowCircle(0,-6,14,'rgba(155,227,255,0.65)','rgba(155,227,255,0)',0.9);
    ctx.fillStyle = '#7db6ff';
    ctx.beginPath(); ctx.ellipse(0, -6, 7, 12, 0, 0, Math.PI*2); ctx.fill();

    if(state.running && !state.paused && !state.gameOver){
      const t = Math.sin(state.t*18)*3;
      drawGlowCircle(0, 34, 18, 'rgba(255,204,102,0.55)', 'rgba(255,204,102,0)', 0.9);
      ctx.fillStyle = '#ffcc66';
      ctx.beginPath();
      ctx.moveTo(0, 28);
      ctx.lineTo(8, 40 + t);
      ctx.lineTo(-8, 40 + t);
      ctx.closePath();
      ctx.fill();
    }

    if(state.subWeapon){
      drawGlowCircle(-34, 8, 16, 'rgba(109,255,178,0.28)', 'rgba(109,255,178,0)', 1);
      drawGlowCircle(34, 8, 16, 'rgba(109,255,178,0.28)', 'rgba(109,255,178,0)', 1);
      ctx.fillStyle = '#6dffb2';
      ctx.beginPath(); ctx.arc(-34, 8, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(34, 8, 4, 0, Math.PI*2); ctx.fill();
    }

    ctx.restore();
  }

  function drawEnemy(e){
    ctx.save();
    ctx.translate(e.x, e.y);

    if(e.carrier){
      e.sparkT += 0.06;
      const pulse = 0.5 + 0.5*Math.sin(e.sparkT*3.2);
      drawGlowCircle(0, -e.h*0.10, 26 + pulse*6, 'rgba(255,215,90,0.55)', 'rgba(255,215,90,0)', 1);
    }

    const g = ctx.createLinearGradient(0, -e.h, 0, e.h);
    g.addColorStop(0, e.carrier ? '#394055' : '#2b3142');
    g.addColorStop(1, e.carrier ? '#141a2b' : '#101421');
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.moveTo(0, -e.h*0.60);
    ctx.lineTo(e.w*0.55, e.h*0.55);
    ctx.lineTo(0, e.h*0.25);
    ctx.lineTo(-e.w*0.55, e.h*0.55);
    ctx.closePath();
    ctx.fill();

    if(e.carrier){
      const pulse = 0.5 + 0.5*Math.sin(e.sparkT*3.2);
      ctx.strokeStyle = `rgba(255,215,90,${0.25 + pulse*0.50})`;
      ctx.lineWidth = 3; ctx.stroke(); ctx.lineWidth = 1;
    }

    ctx.fillStyle = '#ff5a6b';
    ctx.beginPath(); ctx.moveTo(-e.w*0.18, -e.h*0.60); ctx.lineTo(-e.w*0.42, -e.h*0.85); ctx.lineTo(-e.w*0.06, -e.h*0.66); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(e.w*0.18, -e.h*0.60); ctx.lineTo(e.w*0.42, -e.h*0.85); ctx.lineTo(e.w*0.06, -e.h*0.66); ctx.closePath(); ctx.fill();

    drawGlowCircle(-e.w*0.14, -e.h*0.12, 10, 'rgba(255,90,107,0.65)', 'rgba(255,90,107,0)', 0.9);
    drawGlowCircle(e.w*0.14, -e.h*0.12, 10, 'rgba(255,90,107,0.65)', 'rgba(255,90,107,0)', 0.9);
    ctx.fillStyle = '#ff2f4f';
    ctx.beginPath(); ctx.arc(-e.w*0.14, -e.h*0.12, 3.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(e.w*0.14, -e.h*0.12, 3.2, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function drawBoss(){
    const b = state.boss;
    if(!b) return;

    ctx.save();
    ctx.translate(b.x, b.y);

    if(b.hitFlash > 0){
      drawGlowCircle(0, 0, 78, 'rgba(255,255,255,0.35)', 'rgba(255,255,255,0)', 1);
    }

    const hg = ctx.createLinearGradient(0, -b.h, 0, b.h);
    hg.addColorStop(0, '#2a3246');
    hg.addColorStop(1, '#0f1323');
    ctx.fillStyle = hg;

    ctx.beginPath();
    ctx.moveTo(0, -b.h*0.60);
    ctx.lineTo(b.w*0.48, b.h*0.52);
    ctx.lineTo(0, b.h*0.18);
    ctx.lineTo(-b.w*0.48, b.h*0.52);
    ctx.closePath();
    ctx.fill();

    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(0, -b.h*0.56);
    ctx.lineTo(b.w*0.30, 0);
    ctx.lineTo(0, b.h*0.12);
    ctx.lineTo(-b.w*0.30, 0);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#ff5a6b';
    ctx.fillRect(-b.w*0.50, -b.h*0.08, b.w*0.16, b.h*0.34);
    ctx.fillRect(b.w*0.34, -b.h*0.08, b.w*0.16, b.h*0.34);

    drawGlowCircle(0, -b.h*0.08, 48, 'rgba(255,204,102,0.20)', 'rgba(255,204,102,0)', 1);
    drawGlowCircle(0, -b.h*0.08, 42, 'rgba(125,182,255,0.35)', 'rgba(125,182,255,0)', 1);
    ctx.fillStyle = '#7db6ff';
    ctx.beginPath(); ctx.ellipse(0, -b.h*0.08, 22, 14, 0, 0, Math.PI*2); ctx.fill();

    ctx.restore();

    const pad = 18;
    const barW = W - pad*2;
    const barH = 12;
    const ratio = clamp(b.hp / b.hpMax, 0, 1);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    ctx.fillRect(pad, 70, barW, barH);

    ctx.fillStyle = '#ffcc66';
    ctx.fillRect(pad, 70, barW*ratio, barH);

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.strokeRect(pad, 70, barW, barH);
    ctx.globalAlpha = 1;
  }

  function drawBullets(){
    for(const m of pBullets){
      if(m.type==='L'){
        drawGlowCircle(m.x, m.y, 14, 'rgba(217,147,255,0.35)', 'rgba(217,147,255,0)', 1);
        ctx.fillStyle = '#d993ff';
        ctx.fillRect(m.x-1.5, m.y-14, 3, 16);
      } else if(m.type==='S'){
        drawGlowCircle(m.x, m.y, 10, 'rgba(109,255,178,0.25)', 'rgba(109,255,178,0)', 1);
        ctx.fillStyle = '#6dffb2';
        ctx.fillRect(m.x-1.6, m.y-8, 3.2, 10);
      } else {
        drawGlowCircle(m.x, m.y, 12, 'rgba(233,241,255,0.22)', 'rgba(233,241,255,0)', 1);
        ctx.fillStyle = '#e9f1ff';
        ctx.beginPath();
        ctx.roundRect(m.x-2.3, m.y-10, 4.6, 12, 3);
        ctx.fill();
      }
    }

    for(const b of eBullets){
      if(b.spawnDelay && b.spawnDelay > 0) continue;
      if(b.kind==='needle'){
        drawGlowCircle(b.x, b.y, 14, 'rgba(255,204,102,0.26)', 'rgba(255,204,102,0)', 1);
        ctx.fillStyle = '#ffcc66';
        ctx.fillRect(b.x-1.5, b.y-6, 3, 12);
      } else {
        drawGlowCircle(b.x, b.y, 14, 'rgba(255,204,102,0.18)', 'rgba(255,204,102,0)', 1);
        ctx.fillStyle = '#ffcc66';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  function drawPowerups(){
    for(const p of powerups){
      const col = (p.type==='WIDE') ? '#7db6ff' : (p.type==='RAPID' ? '#6dffb2' : '#d993ff');

      ctx.save();
      ctx.translate(p.x, p.y);

      const glow = ctx.createRadialGradient(0,0,3,0,0,18);
      glow.addColorStop(0, col === '#7db6ff' ? 'rgba(125,182,255,0.55)'
                      : col === '#6dffb2' ? 'rgba(109,255,178,0.45)'
                      : 'rgba(217,147,255,0.45)');
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.beginPath(); ctx.roundRect(-13, -13, 26, 26, 7); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.strokeRect(-13, -13, 26, 26);

      ctx.fillStyle = col;
      ctx.fillRect(-2, -13, 4, 26);
      ctx.fillRect(-13, -2, 26, 4);

      ctx.fillStyle = '#0b1020';
      ctx.font = '900 9px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.type==='WIDE'?'W':(p.type==='RAPID'?'R':'L'), 0, 0);

      ctx.restore();
    }
  }

  function drawFx(){
    for(const r of rings){
      ctx.globalAlpha = clamp(r.life*3, 0, 1);
      ctx.strokeStyle = r.col;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.globalAlpha = 0.92;
    for(const p of sparks){
      ctx.fillStyle = p.col;
      ctx.fillRect(p.x, p.y, 3, 3);
    }
    ctx.globalAlpha = 1;
  }

  // ---------- Update ----------
  function update(dt){
    dt *= KID_SPEED;
    state.t += dt;

    if(state.invuln>0) state.invuln = Math.max(0, state.invuln - dt);

    // ì„œë¸Œì›¨í°
    state.subWeapon = (powerSum() >= 10);

    // player move
    const follow = 12;
    if(player.targetX!==null){
      player.x += (player.targetX - player.x) * clamp(follow*dt, 0, 1);
      player.y += (player.targetY - player.y) * clamp(follow*dt, 0, 1);
    }
    player.x = clamp(player.x, player.r+10, W-player.r-10);
    player.y = clamp(player.y, player.r+10, H-player.r-10);

    // auto fire
    state._fireTimer += dt;
    const fireEvery = getFireEvery();
    while(state._fireTimer >= fireEvery){
      state._fireTimer -= fireEvery;
      playerFire();
    }

    if(state.subWeapon){
      state._subTimer += dt;
      const subEvery = clamp(0.24 - Math.min(0.06, powerSum()*0.002), 0.16, 0.24);
      while(state._subTimer >= subEvery){
        state._subTimer -= subEvery;
        subWeaponFire();
      }
    } else {
      state._subTimer = 0;
    }

    // spawn enemies
    if(!state.bossActive){
      state.enemySpawnTimer += dt;
      while(state.enemySpawnTimer >= state.enemySpawnEvery){
        state.enemySpawnTimer -= state.enemySpawnEvery;
        spawnEnemy();
      }
    }

    // enemies update
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      e.y += e.vy * dt;

      e.t0 += dt * e.wiggle;
      e.x += Math.sin(e.t0) * 18 * dt * state.stageMul;
      e.x = clamp(e.x, e.w/2+10, W-e.w/2-10);

      e.shootCd -= dt;
      if(e.shootCd <= 0 && !state.bossActive){
        e.shootCd = rand(0.60, 1.30) * state.enemyFireEvery;
        enemyFireFrom(e);
      }

      if(circleHit(player.x, player.y, player.r*0.90, e.x, e.y, Math.max(e.w,e.h)*0.34)){
        onPlayerHit(1);
      }

      if(e.y - e.h > H + 60){
        enemies.splice(i,1);
      }
    }

    // boss update
    if(state.bossActive){
      const b = state.boss;
      if(b.hitFlash > 0) b.hitFlash = Math.max(0, b.hitFlash - dt);

      if(b.y < b.yStop){
        b.y += b.vy * dt;
        if(b.y > b.yStop) b.y = b.yStop;
      } else {
        b.x += b.dir * b.speedX * dt;
        const left = b.w*0.30;
        const right = W - b.w*0.30;
        if(b.x < left){ b.x = left; b.dir = 1; }
        if(b.x > right){ b.x = right; b.dir = -1; }

        b.shootTimer += dt;
        if(b.shootTimer >= b.shootEvery){
          b.shootTimer = 0;
          bossFirePattern();
        }
      }

      if(circleHit(player.x, player.y, player.r*0.90, b.x, b.y, Math.min(b.w,b.h)*0.55)){
        onPlayerHit(1);
      }
    }

    // player bullets
    for(let i=pBullets.length-1;i>=0;i--){
      const m = pBullets[i];
      if(m.curve && m.curve !== 0){
        const ang = Math.atan2(m.vy, m.vx) + m.curve * dt;
        const sp  = Math.max(1, Math.hypot(m.vx, m.vy));
        m.vx = Math.cos(ang) * sp;
        m.vy = Math.sin(ang) * sp;
      }
      m.x += m.vx * dt;
      m.y += m.vy * dt;
      if(m.y < -70 || m.x < -70 || m.x > W+70) pBullets.splice(i,1);
    }

    // enemy bullets
    for(let i=eBullets.length-1;i>=0;i--){
      const b = eBullets[i];
      if(b.spawnDelay && b.spawnDelay > 0){
        b.spawnDelay -= dt;
        continue;
      }
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      b.life -= dt;
      if(b.life <= 0){
        eBullets.splice(i,1);
        continue;
      }
      if(circleHit(player.x, player.y, player.r*0.85, b.x, b.y, b.r)){
        eBullets.splice(i,1);
        onPlayerHit(1);
        continue;
      }
      if(b.y > H + 110 || b.x < -130 || b.x > W+130) eBullets.splice(i,1);
    }

    // bullets vs enemies
    for(let ei=enemies.length-1; ei>=0; ei--){
      const e = enemies[ei];
      const er = Math.max(e.w,e.h)*0.34;

      for(let bi=pBullets.length-1; bi>=0; bi--){
        const m = pBullets[bi];
        if(circleHit(m.x, m.y, m.r+2, e.x, e.y, er)){
          e.hp -= m.damage;

          if(m.type==='L' && m.pierce>0) m.pierce -= 1;
          else pBullets.splice(bi,1);

          boom(m.x, m.y, 4, m.type==='L' ? '#d993ff' : '#ffcc66');

          if(e.hp <= 0){
            const kindScore = (e.kind==='elite' ? 140 : (e.kind==='heavy' ? 90 : 55));
            state.score += kindScore * state.stageMul;

            state.kills += 1;
            boom(e.x, e.y, e.kind==='elite' ? 28 : 18, '#ffcc66');

            if(e.carrier) dropPowerup(e.x, e.y);
            else if(Math.random() < 0.10) dropPowerup(e.x, e.y);

            enemies.splice(ei,1);
          }
          break;
        }
      }
    }

    // bullets vs boss
    if(state.bossActive && state.boss){
      const b = state.boss;
      const br = Math.min(b.w,b.h)*0.55;

      for(let bi=pBullets.length-1; bi>=0; bi--){
        const m = pBullets[bi];
        if(circleHit(m.x, m.y, m.r+2, b.x, b.y, br)){
          b.hp -= m.damage;
          bossHitFx(m.x, m.y);

          if(m.type==='L' && m.pierce>0) m.pierce -= 1;
          else pBullets.splice(bi,1);

          if(b.hp <= 0){
            state.score += 1800 * state.stageMul;
            boom(b.x, b.y, 90, '#ffcc66');
            state.bossActive = false;
            state.boss = null;
            enemies.length=0;
            eBullets.length=0;
            powerups.length=0;
            stageClear();
          }
          break;
        }
      }
    }

    // powerups update
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      p.y += p.vy * dt;

      if(circleHit(player.x, player.y, player.r*0.95, p.x, p.y, p.r)){
        powerups.splice(i,1);
        applyPowerup(p.type);
        continue;
      }
      if(p.y > H + 60) powerups.splice(i,1);
    }

    // FX update
    for(let i=sparks.length-1;i>=0;i--){
      const p = sparks[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.90;
      p.vy *= 0.90;
      if(p.life<=0) sparks.splice(i,1);
    }
    for(let i=rings.length-1;i>=0;i--){
      const r = rings[i];
      r.life -= dt;
      r.r += r.vr * dt;
      r.vr *= 0.92;
      if(r.life<=0) rings.splice(i,1);
    }

    // boss trigger
    if(!state.bossActive && state.kills >= state.killsToBoss){
      enemies.length=0;
      eBullets.length=0;
      spawnBoss();
    }

    // score tick (ì‹œê°„ ì ìˆ˜ëŠ” ì™„ë§Œ)
    state.score += dt * (6 * state.stageMul);
    updateHud();
  }

  function loop(ts){
    requestAnimationFrame(loop);
    if(!state.lastTs) state.lastTs = ts;
    const dt = Math.min(0.033, (ts - state.lastTs)/1000);
    state.lastTs = ts;

    // âœ… í™”ë©´ ê¹¨ì§ ë°©ì§€
    ctx.setTransform(DPR,0,0,DPR,0,0);

    drawBackground(dt);

    if(state.running && !state.paused && !state.gameOver){
      update(dt);
    }

    drawPowerups();
    for(const e of enemies) drawEnemy(e);
    if(state.bossActive) drawBoss();
    drawBullets();
    drawFx();
    drawPlayer();

    if(state.paused && !state.gameOver){
      ctx.fillStyle='rgba(0,0,0,0.40)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff';
      ctx.font='900 28px system-ui';
      ctx.textAlign='center';
      ctx.fillText('ì¼ì‹œì •ì§€', W/2, H/2);
      ctx.font='700 14px system-ui';
      ctx.fillText('ì˜¤ë¥¸ìª½ ìœ„ "ì¬ê°œ"ë¥¼ ëˆ„ë¥´ì„¸ìš”', W/2, H/2 + 28);
    }
  }

  // init
  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
